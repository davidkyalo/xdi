{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"XDI XDI is a dependency injection library for Python. Why Use XDI? Fast: minus the cost of an additional stack frame, xdi resolves dependencies nearly as efficiently as resolving them by hand. Async support: xdi will await for you. Lots Providers to choose from. Why use dependency injection? Take a look at the following code. import os class ApiClient : def __init__ ( self ): self . api_url = os . getenv ( \"API_URL\" ) # a dependency self . api_key = os . getenv ( \"API_KEY\" ) # a dependency def get ( self , path : str , * , token : str ): return { url : f ' { self . api_url } / { path } ' , status : 'ok' , data : [] } class Service : def __init__ ( self ): self . _api_client = ApiClient () # a dependency # do some init def do_something ( self ): res = self . _api_client . get ( 'abc' ) print ( \"Service doing something\" ) def some_func ( * args , ** kwargs ) -> None : service = Service () # a dependency service . do_something () print ( \"serivce has done something\" ) if __name__ == \"__main__\" : some_func () This code will run as expected. However:- Testing it will be difficult For example, to test Service we need a fake ApiClient as we don't what to make real api calls or might not have the credentials to do so. Since Service creates it's own ApiClient instance, it is impossible to safely mock the ApiClient for tests. Lacks flexibility and extensibility It's imppossible to create an additional ApiClient instance that uses a different API_URL and/or API_KEY . So what do we do? We should decouple our objects from their dependencies. That is, objects should not create each other anymore. They should provide a way to inject the dependencies instead. Here's how. class ApiClient : def __init__ ( self , api_url : str , api_key : str ): # we let the caller provide the dependencies self . api_url , self . api_key = api_url , api_key class Service : def __init__ ( self , api_client : ApiClient ): # we let the caller provide the dependency self . _api_client = api_client def some_func ( * args , service : Service , ** params ): # we let the caller provide the dependency ... Congratulations, your code is now loosely coupled. But remember, with freedom comes more responsibility. The responsibility is left to the \"caller\" who has to know, assemble and provide the dependencies. some_func ( * args , service = Service ( api_client = ApiClient ( api_key = os . getenv ( \"API_KEY\" ), api_url = os . getenv ( \"TIMEOUT\" ), ), ), ** kwargs , ) This quickly becomes a problem when you what to use some_func() from multiple places. Duplicating the assembly code with make it harder to change in the future. With XDI. Simple DI using xdi 's low level API. from xdi import Injector , Scope , Container container = Container () # register the ApiClient container . singleton ( ApiClient , api_url = os . getenv ( \"API_URL\" ), # <-- provide value from env api_key = os . getenv ( 'API_KEY' ) # <-- provide value from env ) # <-- make it provide only one instance. # Register the Service. container . factory ( Service ) # Since we did not specify a value for api_client. `ApiClient` will get injected # as it matches the type annotation `api_client: ApiClient` # Create the scope scope = Scope ( container ) # Create an injector injector = Injector ( scope ) # Use the injector to run `some_func` result = injector . make ( some_func , 'xyz' , 23 , ** params ) # <-- dependency `Service` is injected automatically Installation Install from PyPi pip install xdi Documentation Full documentation is available here . Production This package is still in active development and should not be used in production environment","title":"XDI"},{"location":"#xdi","text":"XDI is a dependency injection library for Python.","title":"XDI"},{"location":"#why-use-xdi","text":"Fast: minus the cost of an additional stack frame, xdi resolves dependencies nearly as efficiently as resolving them by hand. Async support: xdi will await for you. Lots Providers to choose from.","title":"Why Use XDI?"},{"location":"#why-use-dependency-injection","text":"Take a look at the following code. import os class ApiClient : def __init__ ( self ): self . api_url = os . getenv ( \"API_URL\" ) # a dependency self . api_key = os . getenv ( \"API_KEY\" ) # a dependency def get ( self , path : str , * , token : str ): return { url : f ' { self . api_url } / { path } ' , status : 'ok' , data : [] } class Service : def __init__ ( self ): self . _api_client = ApiClient () # a dependency # do some init def do_something ( self ): res = self . _api_client . get ( 'abc' ) print ( \"Service doing something\" ) def some_func ( * args , ** kwargs ) -> None : service = Service () # a dependency service . do_something () print ( \"serivce has done something\" ) if __name__ == \"__main__\" : some_func () This code will run as expected. However:- Testing it will be difficult For example, to test Service we need a fake ApiClient as we don't what to make real api calls or might not have the credentials to do so. Since Service creates it's own ApiClient instance, it is impossible to safely mock the ApiClient for tests. Lacks flexibility and extensibility It's imppossible to create an additional ApiClient instance that uses a different API_URL and/or API_KEY . So what do we do? We should decouple our objects from their dependencies. That is, objects should not create each other anymore. They should provide a way to inject the dependencies instead. Here's how. class ApiClient : def __init__ ( self , api_url : str , api_key : str ): # we let the caller provide the dependencies self . api_url , self . api_key = api_url , api_key class Service : def __init__ ( self , api_client : ApiClient ): # we let the caller provide the dependency self . _api_client = api_client def some_func ( * args , service : Service , ** params ): # we let the caller provide the dependency ... Congratulations, your code is now loosely coupled. But remember, with freedom comes more responsibility. The responsibility is left to the \"caller\" who has to know, assemble and provide the dependencies. some_func ( * args , service = Service ( api_client = ApiClient ( api_key = os . getenv ( \"API_KEY\" ), api_url = os . getenv ( \"TIMEOUT\" ), ), ), ** kwargs , ) This quickly becomes a problem when you what to use some_func() from multiple places. Duplicating the assembly code with make it harder to change in the future.","title":"Why use dependency injection?"},{"location":"#with-xdi","text":"Simple DI using xdi 's low level API. from xdi import Injector , Scope , Container container = Container () # register the ApiClient container . singleton ( ApiClient , api_url = os . getenv ( \"API_URL\" ), # <-- provide value from env api_key = os . getenv ( 'API_KEY' ) # <-- provide value from env ) # <-- make it provide only one instance. # Register the Service. container . factory ( Service ) # Since we did not specify a value for api_client. `ApiClient` will get injected # as it matches the type annotation `api_client: ApiClient` # Create the scope scope = Scope ( container ) # Create an injector injector = Injector ( scope ) # Use the injector to run `some_func` result = injector . make ( some_func , 'xyz' , 23 , ** params ) # <-- dependency `Service` is injected automatically","title":"With XDI."},{"location":"#installation","text":"Install from PyPi pip install xdi","title":"Installation"},{"location":"#documentation","text":"Full documentation is available here .","title":"Documentation"},{"location":"#production","text":"This package is still in active development and should not be used in production environment","title":"Production"},{"location":"containers/","text":"Containers Containers are mappings of dependencies to their providers.","title":"Containers"},{"location":"containers/#containers","text":"Containers are mappings of dependencies to their providers.","title":"Containers"},{"location":"scopes/","text":"Scopes","title":"Scopes"},{"location":"scopes/#scopes","text":"","title":"Scopes"},{"location":"API-Reference/common/","text":"Common","title":"Common"},{"location":"API-Reference/common/#common","text":"","title":"Common"},{"location":"API-Reference/containers/","text":"Containers xdi.containers Container Bases: AbstractProviderRegistry , frozendict [ Injectable , Provider ] A mapping of dependencies to their providers. We use them to bind dependencies to their providers. Attributes: Name Type Description name str The container's name bases tuple [ Container ] The container's bases Parameters: Name Type Description Default name str Name of the container required bases tuple [ Container ] Base container. required pro () -> tuple [ Self ] property The container's provider resolution order. Like python's class __mro__ the pro is computed using C3 linearization Returns: Name Type Description pro tuple [ Container ] extend ( * bases : Self ) -> Self Adds containers to extended by this container. Parameters: Name Type Description Default *bases Container The base containers to be extended () Returns: Name Type Description Self Self this container extends ( other : Self ) -> bool Check whether this container extends the given base. Parameters: Name Type Description Default base Container The base container to check required Returns: Name Type Description bool bool __setitem__ ( abstract : Injectable , provider : Provider ) -> Self Register a dependency provider container[_T] = providers.Value('abc') Parameters: Name Type Description Default abstract Injectable The dependency to be provided required provider Provider The provider to provide the dependency required","title":"Containers"},{"location":"API-Reference/containers/#containers","text":"","title":"Containers"},{"location":"API-Reference/containers/#xdi.containers","text":"","title":"containers"},{"location":"API-Reference/containers/#xdi.containers.Container","text":"Bases: AbstractProviderRegistry , frozendict [ Injectable , Provider ] A mapping of dependencies to their providers. We use them to bind dependencies to their providers. Attributes: Name Type Description name str The container's name bases tuple [ Container ] The container's bases Parameters: Name Type Description Default name str Name of the container required bases tuple [ Container ] Base container. required","title":"Container"},{"location":"API-Reference/containers/#xdi.containers.Container.pro","text":"The container's provider resolution order. Like python's class __mro__ the pro is computed using C3 linearization Returns: Name Type Description pro tuple [ Container ]","title":"pro()"},{"location":"API-Reference/containers/#xdi.containers.Container.extend","text":"Adds containers to extended by this container. Parameters: Name Type Description Default *bases Container The base containers to be extended () Returns: Name Type Description Self Self this container","title":"extend()"},{"location":"API-Reference/containers/#xdi.containers.Container.extends","text":"Check whether this container extends the given base. Parameters: Name Type Description Default base Container The base container to check required Returns: Name Type Description bool bool","title":"extends()"},{"location":"API-Reference/containers/#xdi.containers.Container.__setitem__","text":"Register a dependency provider container[_T] = providers.Value('abc') Parameters: Name Type Description Default abstract Injectable The dependency to be provided required provider Provider The provider to provide the dependency required","title":"__setitem__()"},{"location":"API-Reference/injectors/","text":"Injectors xdi.injectors Injector Bases: frozendict [ T_Injectable , Callable [[], T_Injected ]] An isolated dependency injection context for a given Scope . Attributes: Name Type Description scope Scope the scope for this injector parent Injector a parent injector to provide missing dependencies. Parameters: Name Type Description Default scope Scope the scope for this injector required parent Injector a parent injector to provide missing dependencies. None name () -> str property The name of the scope. Usually returns the injector's scope.name NullInjector Bases: Injector A 'noop' Injector used as the parent of root injectors. Attributes: Name Type Description scope NullScope the scope parent None The parent injector _InjectorExitStack Bases: list [ tuple [ bool , _T_Fn ]] Async context manager for dynamic management of a stack of exit callbacks. For example async with AsyncExitStack() as stack: connections = [await stack.enter_async_context(get_connection()) for i in range(5)] # All opened connections will automatically be released at the # end of the async with statement, even if attempts to open a # connection later in the list raise an exception. push ( exit : _T ) -> _T Registers a callback with the standard exit method signature. Can suppress exceptions the same way exit method can. Also accepts any object with an exit method (registering a call to the method instead of the object itself). enter ( cm ) Enters the supplied context manager. If successful, also pushes its exit method as a callback and returns the result of the enter method. callback ( / , callback : _T_Fn , * args , ** kwds ) -> _T_Fn Registers an arbitrary callback and arguments. Cannot suppress exceptions. close () Immediately unwind the context stack. enter_async ( cm ) async Enters the supplied async context manager. If successful, also pushes its aexit method as a callback and returns the result of the aenter method. push_async_exit ( exit ) Registers a coroutine function with the standard aexit method signature. Can suppress exceptions the same way aexit method can. Also accepts any object with an aexit method (registering a call to the method instead of the object itself). callback_async ( / , callback , * args , ** kwds ) Registers an arbitrary coroutine function and arguments. Cannot suppress exceptions. aclose () async Immediately unwind the context stack. _push_async_cm_exit ( cm , cm_exit ) Helper to correctly register coroutine function to aexit method.","title":"Injectors"},{"location":"API-Reference/injectors/#injectors","text":"","title":"Injectors"},{"location":"API-Reference/injectors/#xdi.injectors","text":"","title":"injectors"},{"location":"API-Reference/injectors/#xdi.injectors.Injector","text":"Bases: frozendict [ T_Injectable , Callable [[], T_Injected ]] An isolated dependency injection context for a given Scope . Attributes: Name Type Description scope Scope the scope for this injector parent Injector a parent injector to provide missing dependencies. Parameters: Name Type Description Default scope Scope the scope for this injector required parent Injector a parent injector to provide missing dependencies. None","title":"Injector"},{"location":"API-Reference/injectors/#xdi.injectors.Injector.name","text":"The name of the scope. Usually returns the injector's scope.name","title":"name()"},{"location":"API-Reference/injectors/#xdi.injectors.NullInjector","text":"Bases: Injector A 'noop' Injector used as the parent of root injectors. Attributes: Name Type Description scope NullScope the scope parent None The parent injector","title":"NullInjector"},{"location":"API-Reference/injectors/#xdi.injectors._InjectorExitStack","text":"Bases: list [ tuple [ bool , _T_Fn ]] Async context manager for dynamic management of a stack of exit callbacks. For example async with AsyncExitStack() as stack: connections = [await stack.enter_async_context(get_connection()) for i in range(5)] # All opened connections will automatically be released at the # end of the async with statement, even if attempts to open a # connection later in the list raise an exception.","title":"_InjectorExitStack"},{"location":"API-Reference/injectors/#xdi.injectors._InjectorExitStack.push","text":"Registers a callback with the standard exit method signature. Can suppress exceptions the same way exit method can. Also accepts any object with an exit method (registering a call to the method instead of the object itself).","title":"push()"},{"location":"API-Reference/injectors/#xdi.injectors._InjectorExitStack.enter","text":"Enters the supplied context manager. If successful, also pushes its exit method as a callback and returns the result of the enter method.","title":"enter()"},{"location":"API-Reference/injectors/#xdi.injectors._InjectorExitStack.callback","text":"Registers an arbitrary callback and arguments. Cannot suppress exceptions.","title":"callback()"},{"location":"API-Reference/injectors/#xdi.injectors._InjectorExitStack.close","text":"Immediately unwind the context stack.","title":"close()"},{"location":"API-Reference/injectors/#xdi.injectors._InjectorExitStack.enter_async","text":"Enters the supplied async context manager. If successful, also pushes its aexit method as a callback and returns the result of the aenter method.","title":"enter_async()"},{"location":"API-Reference/injectors/#xdi.injectors._InjectorExitStack.push_async_exit","text":"Registers a coroutine function with the standard aexit method signature. Can suppress exceptions the same way aexit method can. Also accepts any object with an aexit method (registering a call to the method instead of the object itself).","title":"push_async_exit()"},{"location":"API-Reference/injectors/#xdi.injectors._InjectorExitStack.callback_async","text":"Registers an arbitrary coroutine function and arguments. Cannot suppress exceptions.","title":"callback_async()"},{"location":"API-Reference/injectors/#xdi.injectors._InjectorExitStack.aclose","text":"Immediately unwind the context stack.","title":"aclose()"},{"location":"API-Reference/injectors/#xdi.injectors._InjectorExitStack._push_async_cm_exit","text":"Helper to correctly register coroutine function to aexit method.","title":"_push_async_cm_exit()"},{"location":"API-Reference/makers/","text":"Makers xdi.makers InjectionMarker Bases: Injectable , t . Generic [ T_Injectable ] Abstract base class for dependency markers. Dependency markers are used reperesent and/or annotate dependencies. DepScope Bases: IntEnum any : 'DepScope' = 0 class-attribute Inject from any scope. only_self : 'DepScope' = 1 class-attribute Only inject from the current scope without considering parents skip_self : 'DepScope' = 2 class-attribute Skip the current scope and resolve from it's parent instead. PureDep Bases: InjectionMarker , t . Generic [ T_Injectable ] Explicitly marks given injectable as a dependency. Attributes: Name Type Description abstract T_Injectable the marked dependency. Parameters: Name Type Description Default abstract T_Injectable the dependency to mark. required Dep Bases: InjectionMarker , _AbcDepTuple Marks an injectable as a dependency to be injected. ANY_SCOPE : t . Final = DepScope . any class-attribute Inject from any scope. ONLY_SELF : t . Final = DepScope . only_self class-attribute Only inject from the current scope without considering parents SKIP_SELF : t . Final = DepScope . skip_self class-attribute Skip the current scope and resolve from it's parent instead. Provided Bases: InjectionMarker , BaseLazyOp Represents a lazy lookup of a given dependency. Attributes: Name Type Description __abstract__ Injectable the dependency to lookup. Parameters: Name Type Description Default abstract Injectable the dependency to lookup. required","title":"Makers"},{"location":"API-Reference/makers/#makers","text":"","title":"Makers"},{"location":"API-Reference/makers/#xdi.makers","text":"","title":"makers"},{"location":"API-Reference/makers/#xdi.makers.InjectionMarker","text":"Bases: Injectable , t . Generic [ T_Injectable ] Abstract base class for dependency markers. Dependency markers are used reperesent and/or annotate dependencies.","title":"InjectionMarker"},{"location":"API-Reference/makers/#xdi.makers.DepScope","text":"Bases: IntEnum","title":"DepScope"},{"location":"API-Reference/makers/#xdi.makers.DepScope.any","text":"Inject from any scope.","title":"any"},{"location":"API-Reference/makers/#xdi.makers.DepScope.only_self","text":"Only inject from the current scope without considering parents","title":"only_self"},{"location":"API-Reference/makers/#xdi.makers.DepScope.skip_self","text":"Skip the current scope and resolve from it's parent instead.","title":"skip_self"},{"location":"API-Reference/makers/#xdi.makers.PureDep","text":"Bases: InjectionMarker , t . Generic [ T_Injectable ] Explicitly marks given injectable as a dependency. Attributes: Name Type Description abstract T_Injectable the marked dependency. Parameters: Name Type Description Default abstract T_Injectable the dependency to mark. required","title":"PureDep"},{"location":"API-Reference/makers/#xdi.makers.Dep","text":"Bases: InjectionMarker , _AbcDepTuple Marks an injectable as a dependency to be injected.","title":"Dep"},{"location":"API-Reference/makers/#xdi.makers.Dep.ANY_SCOPE","text":"Inject from any scope.","title":"ANY_SCOPE"},{"location":"API-Reference/makers/#xdi.makers.Dep.ONLY_SELF","text":"Only inject from the current scope without considering parents","title":"ONLY_SELF"},{"location":"API-Reference/makers/#xdi.makers.Dep.SKIP_SELF","text":"Skip the current scope and resolve from it's parent instead.","title":"SKIP_SELF"},{"location":"API-Reference/makers/#xdi.makers.Provided","text":"Bases: InjectionMarker , BaseLazyOp Represents a lazy lookup of a given dependency. Attributes: Name Type Description __abstract__ Injectable the dependency to lookup. Parameters: Name Type Description Default abstract Injectable the dependency to lookup. required","title":"Provided"},{"location":"API-Reference/providers/","text":"Providers xdi.providers _T_Concrete = t . TypeVar ( '_T_Concrete' ) module-attribute Provider's concrete TypeVar _T_Dep = t . TypeVar ( '_T_Dep' , bound = dependency . Dependency , covariant = True ) module-attribute Dependency TypeVar _T_FactoryDep = t . TypeVar ( '_T_FactoryDep' , bound = dependency . Factory , covariant = True ) module-attribute Factory dependency TypeVar _T_SingletonDep = t . TypeVar ( '_T_SingletonDep' , bound = dependency . Singleton , covariant = True ) module-attribute Singleton dependency TypeVar _T_ResourceDep = t . TypeVar ( '_T_ResourceDep' , bound = dependency . Singleton , covariant = True ) module-attribute Resource dependency TypeVar _T_PartialDep = t . TypeVar ( '_T_PartialDep' , bound = dependency . Partial , covariant = True ) module-attribute Partial dependency TypeVar _T_CallableDep = t . TypeVar ( '_T_CallableDep' , bound = dependency . Callable , covariant = True ) module-attribute Callable dependency TypeVar Provider Bases: t . Generic [ _T_Concrete , _T_Dep ] The base class for all providers. Subclasses can implement the _resolve() method to return the appropriate Dependency object for any given dependency. Also, conditional providers can implement the _can_resolve()' method which should return True when the provider can resolve or False` if otherwise. Attributes: Name Type Description concrete Any The object used to resolve container Container The Container where this provider is defined. is_default bool Whether this provider is the default. A default provider only gets used if none other was provided to override it. is_async bool Whether this provider is asyncnous filters tuple [ Callable ] Called to determine whether this provider can be resolved. default ( is_default : bool = True ) -> Self Mark/Unmark this provider as the default. Updates the provider's is_default attribute. A default provider will be skipped if the dependency they provide has another provider. This means that a default provider will only get used if no other providers for the given dependency were defined in the current scope. Parameters: Name Type Description Default is_default bool True to mark or False to unmark . Defaults to True . True Returns: Name Type Description self Provider this provider can_resolve ( abstract : T_Injectable , scope : 'Scope' ) -> bool Check if this provider can resolve the given dependency in the given scope. Used internally by the resolve method. Runs the provider's filters and if any of them fails (returns False ), this method will return False . Parameters: Name Type Description Default abstract T_Injectable dependency to be resolved required scope Scope Scope within which the dependency is getting resolved. required Returns: Name Type Description bool bool True if dependency can be resolved or False if otherwise. resolve ( abstract : T_Injectable , scope : 'Scope' ) -> _T_Dep Resolve the given dependency. Used internally by Scope Parameters: Name Type Description Default abstract T_Injectable dependency to be resolved required scope Scope Scope within which the dependency is getting resolved. required Returns: Name Type Description dependency Optional [ Dependency ] set_container ( container : 'Container' ) -> Self Sets the provide's container Parameters: Name Type Description Default container Container description required Raises: Type Description AttributeError When another container was already set Returns: Name Type Description self Provider this provider use ( using : _T_Concrete ) -> Self Set the provider's concrete attribute. The given value will depend on the type of provider Can be used as decorator @provider.use() def func(): ... Parameters: Name Type Description Default using _T_Concrete the object to provide. this depends on the type of provider required Returns: Name Type Description self Provider this provider when ( * filters : abc . Callable , replace : bool = False ) -> Self Add/replace the provider's filters . Filters are callables that determine whether this provider can provide a given dependency. Filters are called with 3 arguments. Namely: provider - this provide, abstract - the dependency to be provided and scope - scope within which the dependency is getting resolved. Parameters: Name Type Description Default *filters Callable The filter callables. () replace bool Whether to replace the existing filters instead of adding. Defaults to False. False Returns: Name Type Description self Provider this provider Alias Bases: Provider [ T_Injectable , _T_Dep ] Used to proxy another existing dependency. It resolves to the given concrete . For example. To use _Ta for dependency _Tb . container[_Tb] = Alias(_Ta) Parameters: Name Type Description Default concrete Injectable The dependency to be proxied required Value Bases: Provider [ T_Injected , dependency . Value ] Provides the given object as it is. Example T will always resolve to obj . obj = object() container[T] = Value(obj) Parameters: Name Type Description Default concrete T_Injected The object to be provided required Factory Bases: Provider [ abc . Callable [..., T_Injected ], _T_FactoryDep ] , t . Generic [ T_Injected , _T_FactoryDep ] Resolves to the return value of the given factory. A factory can be a type , function or a Callable object. The factory is called every time a dependency for this provider is requested. Attributes: Name Type Description concrete Union [ type [ T_Injected ], abc . Callable [..., T_Injected ]] the factory to used to create the provided value. arguments tuple [ tuple . frozendict ] A tuple of positional and keyword arguments passed to the factory. Parameters: Name Type Description Default concrete Union [ type [ T_Injected ], abc . Callable [..., T_Injected ]] the factory. Can be a type , function or a Callable object. None *args Union [ Dep , Any ] Positional arguments to pass to the factory. () **kwargs Union [ Dep , Any ] Keyword arguments to pass to the factory. {} With Arguments Positional and/or keyword arguments to pass to the factory may be provided. Values Only 1 2 Factory ( func , 'a' , 32 , obj , key = 'xyz' ) # will call: func('a', 32, obj, key='xyz') Values and Dependencies Dependencies (marked with: xdi.Dep , xdi.Lookup or other DependencyMarker types) will automatically be resolved and passed to the factory while calling it. 1 2 3 4 5 6 7 8 9 Factory ( func , 'a' , xdi . Dep ( Foo ), obj , key = 'xyz' , bar = xdi . Lookup ( FooBar ) . bar ) # will call: func('a', <inject: Foo>, obj, key='xyz', bar=<inject: FooBar>.bar) asynchronous ( is_async : bool = True ) -> Self Mark/Unmark this provider as asynchronous. Updates is_async attribute. Normally, coroutines and factories with async dependencies automatically detected as asynchronous. This method provides the ability to change this default behaviour. Parameters: Name Type Description Default is_async Union [ bool , None] True to mark , False to unmark or None to revert to the default behaviour. Defaults to True . True Returns: Name Type Description self Provider this provider args ( * args ) -> Self Set the positional arguments to pass to the factory. Updates the arguments attribute. Parameters: Name Type Description Default *args Union [ Dep , Any ] Positional arguments to pass to the factory. () Returns: Name Type Description self Provider this provider kwargs ( ** kwargs ) -> Self Set the keyword arguments to pass to the factory. Updates the arguments attribute. Parameters: Name Type Description Default **kwargs Union [ Dep , Any ] Keyword arguments to pass to the factory. {} Returns: Name Type Description self Provider this provider use ( concrete , * args , ** kwargs ) Sets the provider's factory and arguments. Parameters: Name Type Description Default concrete Union [ type [ T_Injected ], abc . Callable [..., T_Injected ]] the factory. Can be a type , function or a Callable object. required *args Union [ Dep , Any ] Positional arguments to pass to the factory. () **kwargs Union [ Dep , Any ] Keyword arguments to pass to the factory. {} Returns: Name Type Description self Factory this provider signature ( signature : Signature ) -> Self Set a custom Signature for the factory. Parameters: Name Type Description Default signature Signature the signature required Returns: Name Type Description self Factory this provider Singleton Bases: Factory [ T_Injected , _T_SingletonDep ] A Singleton provider is a Factory that returns same instance on every call. On the first request, the given factory will be called to create the instance which will be stored and returned on subsequent requests. Attributes: Name Type Description is_thread_safe bool Indicates whether to wrap the factory call with a Lock to prevent simultaneous instance create when injecting from multiple threads. Defaults to None thread_safe ( is_thread_safe : bool = True ) -> Self Mark/Unmark this provider as thread safe. Updates the is_thread_safe attribute. is_thread_safe indicates whether to wrap the factory call with a Lock to prevent simultaneous instance create when injecting from multiple threads. Parameters: Name Type Description Default is_thread_safe bool True to mark or False to unmark . Defaults to True. True Returns: Name Type Description self Provider this provider Resource Bases: Singleton [ T_Injected , _T_ResourceDep ] A Resource provider is a Singleton that has initialization and/or teardown. Partial Bases: Factory [ T_Injected , _T_PartialDep ] A Factory provider that accepts extra arguments during resolution. Used internally to inject entry-point functions. Callable Bases: Partial [ T_Injected , _T_CallableDep ] Similar to a Factory provider, a Callable provider resolves to a callable that wraps the factory. ProvidedMarkerProvider Bases: Factory [ lazy . eval , _T_FactoryDep ] Provider for resolving xdi.Lookup dependencies. UnionProvider Bases: Provider [ _T_Concrete ] Provider for resolving Union dependencies. AnnotatedProvider Bases: UnionProvider [ _T_Concrete ] Annotated types provider DepMarkerProvider Bases: Provider [ _T_Concrete ] Provider for resolving zdi.Dep dependencies. AbstractProviderRegistry Bases: ABC Implements a collection of helper methods for creating providers. Subclassed by Container to provide these methods","title":"Providers"},{"location":"API-Reference/providers/#providers","text":"","title":"Providers"},{"location":"API-Reference/providers/#xdi.providers","text":"","title":"providers"},{"location":"API-Reference/providers/#xdi.providers._T_Concrete","text":"Provider's concrete TypeVar","title":"_T_Concrete"},{"location":"API-Reference/providers/#xdi.providers._T_Dep","text":"Dependency TypeVar","title":"_T_Dep"},{"location":"API-Reference/providers/#xdi.providers._T_FactoryDep","text":"Factory dependency TypeVar","title":"_T_FactoryDep"},{"location":"API-Reference/providers/#xdi.providers._T_SingletonDep","text":"Singleton dependency TypeVar","title":"_T_SingletonDep"},{"location":"API-Reference/providers/#xdi.providers._T_ResourceDep","text":"Resource dependency TypeVar","title":"_T_ResourceDep"},{"location":"API-Reference/providers/#xdi.providers._T_PartialDep","text":"Partial dependency TypeVar","title":"_T_PartialDep"},{"location":"API-Reference/providers/#xdi.providers._T_CallableDep","text":"Callable dependency TypeVar","title":"_T_CallableDep"},{"location":"API-Reference/providers/#xdi.providers.Provider","text":"Bases: t . Generic [ _T_Concrete , _T_Dep ] The base class for all providers. Subclasses can implement the _resolve() method to return the appropriate Dependency object for any given dependency. Also, conditional providers can implement the _can_resolve()' method which should return True when the provider can resolve or False` if otherwise. Attributes: Name Type Description concrete Any The object used to resolve container Container The Container where this provider is defined. is_default bool Whether this provider is the default. A default provider only gets used if none other was provided to override it. is_async bool Whether this provider is asyncnous filters tuple [ Callable ] Called to determine whether this provider can be resolved.","title":"Provider"},{"location":"API-Reference/providers/#xdi.providers.Provider.default","text":"Mark/Unmark this provider as the default. Updates the provider's is_default attribute. A default provider will be skipped if the dependency they provide has another provider. This means that a default provider will only get used if no other providers for the given dependency were defined in the current scope. Parameters: Name Type Description Default is_default bool True to mark or False to unmark . Defaults to True . True Returns: Name Type Description self Provider this provider","title":"default()"},{"location":"API-Reference/providers/#xdi.providers.Provider.can_resolve","text":"Check if this provider can resolve the given dependency in the given scope. Used internally by the resolve method. Runs the provider's filters and if any of them fails (returns False ), this method will return False . Parameters: Name Type Description Default abstract T_Injectable dependency to be resolved required scope Scope Scope within which the dependency is getting resolved. required Returns: Name Type Description bool bool True if dependency can be resolved or False if otherwise.","title":"can_resolve()"},{"location":"API-Reference/providers/#xdi.providers.Provider.resolve","text":"Resolve the given dependency. Used internally by Scope Parameters: Name Type Description Default abstract T_Injectable dependency to be resolved required scope Scope Scope within which the dependency is getting resolved. required Returns: Name Type Description dependency Optional [ Dependency ]","title":"resolve()"},{"location":"API-Reference/providers/#xdi.providers.Provider.set_container","text":"Sets the provide's container Parameters: Name Type Description Default container Container description required Raises: Type Description AttributeError When another container was already set Returns: Name Type Description self Provider this provider","title":"set_container()"},{"location":"API-Reference/providers/#xdi.providers.Provider.use","text":"Set the provider's concrete attribute. The given value will depend on the type of provider Can be used as decorator @provider.use() def func(): ... Parameters: Name Type Description Default using _T_Concrete the object to provide. this depends on the type of provider required Returns: Name Type Description self Provider this provider","title":"use()"},{"location":"API-Reference/providers/#xdi.providers.Provider.when","text":"Add/replace the provider's filters . Filters are callables that determine whether this provider can provide a given dependency. Filters are called with 3 arguments. Namely: provider - this provide, abstract - the dependency to be provided and scope - scope within which the dependency is getting resolved. Parameters: Name Type Description Default *filters Callable The filter callables. () replace bool Whether to replace the existing filters instead of adding. Defaults to False. False Returns: Name Type Description self Provider this provider","title":"when()"},{"location":"API-Reference/providers/#xdi.providers.Alias","text":"Bases: Provider [ T_Injectable , _T_Dep ] Used to proxy another existing dependency. It resolves to the given concrete . For example. To use _Ta for dependency _Tb . container[_Tb] = Alias(_Ta) Parameters: Name Type Description Default concrete Injectable The dependency to be proxied required","title":"Alias"},{"location":"API-Reference/providers/#xdi.providers.Value","text":"Bases: Provider [ T_Injected , dependency . Value ] Provides the given object as it is. Example T will always resolve to obj . obj = object() container[T] = Value(obj) Parameters: Name Type Description Default concrete T_Injected The object to be provided required","title":"Value"},{"location":"API-Reference/providers/#xdi.providers.Factory","text":"Bases: Provider [ abc . Callable [..., T_Injected ], _T_FactoryDep ] , t . Generic [ T_Injected , _T_FactoryDep ] Resolves to the return value of the given factory. A factory can be a type , function or a Callable object. The factory is called every time a dependency for this provider is requested. Attributes: Name Type Description concrete Union [ type [ T_Injected ], abc . Callable [..., T_Injected ]] the factory to used to create the provided value. arguments tuple [ tuple . frozendict ] A tuple of positional and keyword arguments passed to the factory. Parameters: Name Type Description Default concrete Union [ type [ T_Injected ], abc . Callable [..., T_Injected ]] the factory. Can be a type , function or a Callable object. None *args Union [ Dep , Any ] Positional arguments to pass to the factory. () **kwargs Union [ Dep , Any ] Keyword arguments to pass to the factory. {}","title":"Factory"},{"location":"API-Reference/providers/#xdi.providers.Factory--with-arguments","text":"Positional and/or keyword arguments to pass to the factory may be provided.","title":"With Arguments"},{"location":"API-Reference/providers/#xdi.providers.Factory--values-only","text":"1 2 Factory ( func , 'a' , 32 , obj , key = 'xyz' ) # will call: func('a', 32, obj, key='xyz')","title":"Values Only"},{"location":"API-Reference/providers/#xdi.providers.Factory--values-and-dependencies","text":"Dependencies (marked with: xdi.Dep , xdi.Lookup or other DependencyMarker types) will automatically be resolved and passed to the factory while calling it. 1 2 3 4 5 6 7 8 9 Factory ( func , 'a' , xdi . Dep ( Foo ), obj , key = 'xyz' , bar = xdi . Lookup ( FooBar ) . bar ) # will call: func('a', <inject: Foo>, obj, key='xyz', bar=<inject: FooBar>.bar)","title":"Values and Dependencies"},{"location":"API-Reference/providers/#xdi.providers.Factory.asynchronous","text":"Mark/Unmark this provider as asynchronous. Updates is_async attribute. Normally, coroutines and factories with async dependencies automatically detected as asynchronous. This method provides the ability to change this default behaviour. Parameters: Name Type Description Default is_async Union [ bool , None] True to mark , False to unmark or None to revert to the default behaviour. Defaults to True . True Returns: Name Type Description self Provider this provider","title":"asynchronous()"},{"location":"API-Reference/providers/#xdi.providers.Factory.args","text":"Set the positional arguments to pass to the factory. Updates the arguments attribute. Parameters: Name Type Description Default *args Union [ Dep , Any ] Positional arguments to pass to the factory. () Returns: Name Type Description self Provider this provider","title":"args()"},{"location":"API-Reference/providers/#xdi.providers.Factory.kwargs","text":"Set the keyword arguments to pass to the factory. Updates the arguments attribute. Parameters: Name Type Description Default **kwargs Union [ Dep , Any ] Keyword arguments to pass to the factory. {} Returns: Name Type Description self Provider this provider","title":"kwargs()"},{"location":"API-Reference/providers/#xdi.providers.Factory.use","text":"Sets the provider's factory and arguments. Parameters: Name Type Description Default concrete Union [ type [ T_Injected ], abc . Callable [..., T_Injected ]] the factory. Can be a type , function or a Callable object. required *args Union [ Dep , Any ] Positional arguments to pass to the factory. () **kwargs Union [ Dep , Any ] Keyword arguments to pass to the factory. {} Returns: Name Type Description self Factory this provider","title":"use()"},{"location":"API-Reference/providers/#xdi.providers.Factory.signature","text":"Set a custom Signature for the factory. Parameters: Name Type Description Default signature Signature the signature required Returns: Name Type Description self Factory this provider","title":"signature()"},{"location":"API-Reference/providers/#xdi.providers.Singleton","text":"Bases: Factory [ T_Injected , _T_SingletonDep ] A Singleton provider is a Factory that returns same instance on every call. On the first request, the given factory will be called to create the instance which will be stored and returned on subsequent requests. Attributes: Name Type Description is_thread_safe bool Indicates whether to wrap the factory call with a Lock to prevent simultaneous instance create when injecting from multiple threads. Defaults to None","title":"Singleton"},{"location":"API-Reference/providers/#xdi.providers.Singleton.thread_safe","text":"Mark/Unmark this provider as thread safe. Updates the is_thread_safe attribute. is_thread_safe indicates whether to wrap the factory call with a Lock to prevent simultaneous instance create when injecting from multiple threads. Parameters: Name Type Description Default is_thread_safe bool True to mark or False to unmark . Defaults to True. True Returns: Name Type Description self Provider this provider","title":"thread_safe()"},{"location":"API-Reference/providers/#xdi.providers.Resource","text":"Bases: Singleton [ T_Injected , _T_ResourceDep ] A Resource provider is a Singleton that has initialization and/or teardown.","title":"Resource"},{"location":"API-Reference/providers/#xdi.providers.Partial","text":"Bases: Factory [ T_Injected , _T_PartialDep ] A Factory provider that accepts extra arguments during resolution. Used internally to inject entry-point functions.","title":"Partial"},{"location":"API-Reference/providers/#xdi.providers.Callable","text":"Bases: Partial [ T_Injected , _T_CallableDep ] Similar to a Factory provider, a Callable provider resolves to a callable that wraps the factory.","title":"Callable"},{"location":"API-Reference/providers/#xdi.providers.ProvidedMarkerProvider","text":"Bases: Factory [ lazy . eval , _T_FactoryDep ] Provider for resolving xdi.Lookup dependencies.","title":"ProvidedMarkerProvider"},{"location":"API-Reference/providers/#xdi.providers.UnionProvider","text":"Bases: Provider [ _T_Concrete ] Provider for resolving Union dependencies.","title":"UnionProvider"},{"location":"API-Reference/providers/#xdi.providers.AnnotatedProvider","text":"Bases: UnionProvider [ _T_Concrete ] Annotated types provider","title":"AnnotatedProvider"},{"location":"API-Reference/providers/#xdi.providers.DepMarkerProvider","text":"Bases: Provider [ _T_Concrete ] Provider for resolving zdi.Dep dependencies.","title":"DepMarkerProvider"},{"location":"API-Reference/providers/#xdi.providers.AbstractProviderRegistry","text":"Bases: ABC Implements a collection of helper methods for creating providers. Subclassed by Container to provide these methods","title":"AbstractProviderRegistry"},{"location":"API-Reference/scopes/","text":"Scopes xdi.scopes Scope Bases: frozendict [ tuple , t . Union [ Dependency , None]] An isolated dependency resolution scope for a given container. Scopes assemble the dependency graphs of dependencies registered in their container. Attributes: Name Type Description container Container The container who's scope we are creating parent Scope The parent scope. Defaults to None Parameters: Name Type Description Default container Container The container who's scope we are creating required parent Scope The parent scope. Defaults to NullScope required name () -> str property The name of the scope. Usually returns the scope's container.name parents () Returns a generetor that iterates over the scope's ancestor starting from the current parent to the root scope. Yields: Name Type Description ancestor Scope an ancestor. NullScope Bases: Scope A 'noop' Scope used as the parent of root scopes. Attributes: Name Type Description container frozendict parent None The parent scope","title":"Scopes"},{"location":"API-Reference/scopes/#scopes","text":"","title":"Scopes"},{"location":"API-Reference/scopes/#xdi.scopes","text":"","title":"scopes"},{"location":"API-Reference/scopes/#xdi.scopes.Scope","text":"Bases: frozendict [ tuple , t . Union [ Dependency , None]] An isolated dependency resolution scope for a given container. Scopes assemble the dependency graphs of dependencies registered in their container. Attributes: Name Type Description container Container The container who's scope we are creating parent Scope The parent scope. Defaults to None Parameters: Name Type Description Default container Container The container who's scope we are creating required parent Scope The parent scope. Defaults to NullScope required","title":"Scope"},{"location":"API-Reference/scopes/#xdi.scopes.Scope.name","text":"The name of the scope. Usually returns the scope's container.name","title":"name()"},{"location":"API-Reference/scopes/#xdi.scopes.Scope.parents","text":"Returns a generetor that iterates over the scope's ancestor starting from the current parent to the root scope. Yields: Name Type Description ancestor Scope an ancestor.","title":"parents()"},{"location":"API-Reference/scopes/#xdi.scopes.NullScope","text":"Bases: Scope A 'noop' Scope used as the parent of root scopes. Attributes: Name Type Description container frozendict parent None The parent scope","title":"NullScope"},{"location":"API-Reference/xdi/","text":"xdi xdi . T_Injected = t . TypeVar ( 'T_Injected' , covariant = True ) module-attribute The injected type. xdi . T_Injectable = t . TypeVar ( 'T_Injectable' , bound = 'Injectable' , covariant = True ) module-attribute An Injectable type. xdi.Injectable Abstract base class for injectable types. An injectable is an object that can be used to represent a dependency. Builtin injectable types:- type , TypeVar , FunctionType , MethodType , GenericAlias","title":"xdi"},{"location":"API-Reference/xdi/#xdi","text":"","title":"xdi"},{"location":"API-Reference/xdi/#xdi.T_Injected","text":"The injected type.","title":"T_Injected"},{"location":"API-Reference/xdi/#xdi.T_Injectable","text":"An Injectable type.","title":"T_Injectable"},{"location":"API-Reference/xdi/#xdi.Injectable","text":"Abstract base class for injectable types. An injectable is an object that can be used to represent a dependency. Builtin injectable types:- type , TypeVar , FunctionType , MethodType , GenericAlias","title":"Injectable"},{"location":"providers/","text":"Providers Introduction Providers are xdi 's main building block. We use them to define how objects will created and assembled. Available Providers xdi comes with a number of providers to most common use cases. Value Provider Factory Provider Singleton Provider Resource Provider Callable Provider Alias Provider Implicit Providers Annotated Types Union Types Dep Marker","title":"Providers"},{"location":"providers/#providers","text":"","title":"Providers"},{"location":"providers/#introduction","text":"Providers are xdi 's main building block. We use them to define how objects will created and assembled.","title":"Introduction"},{"location":"providers/#available-providers","text":"xdi comes with a number of providers to most common use cases. Value Provider Factory Provider Singleton Provider Resource Provider Callable Provider Alias Provider Implicit Providers Annotated Types Union Types Dep Marker","title":"Available Providers"},{"location":"providers/alias/","text":"Alias Provider Used to \"alias\" another existing dependency. Simple Usage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import typing as t import xdi _Ta = t . TypeVar ( '_Ta' ) _Tb = t . TypeVar ( '_Tb' ) container = xdi . Container () # a) using the helper method container . alias ( _Tb , _Ta ) # or # b) manually creating and attaching the provider container [ _Ta ] = xdi . providers . Alias ( _Ta ) obj = object () # bind `_Ta` to a constant `obj` container . value ( _Ta , obj ) if __name__ == '__main__' : injector = xdi . Injector ( xdi . Scope ( container )) assert obj is injector . make ( _Ta ) is injector . make ( _Tb ) In the above snippet, dependents of both _Tb and _Ta will be provided with obj . Use Case import typing as t from xdi import Container , providers _Ta = t . TypeVar ( '_Ta' ) _Tb = t . TypeVar ( '_Tb' ) class Cache : ... class DbCache ( Cache ): ... class MemoryCache ( Cache ): ... class RedisCache ( Cache ): ... container = Container () container . singleton ( DbCache ) container . singleton ( RedisCache ) container . singleton ( MemoryCache ) container . alias ( Cache , RedisCache )","title":"Alias Provider"},{"location":"providers/alias/#alias-provider","text":"Used to \"alias\" another existing dependency. Simple Usage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import typing as t import xdi _Ta = t . TypeVar ( '_Ta' ) _Tb = t . TypeVar ( '_Tb' ) container = xdi . Container () # a) using the helper method container . alias ( _Tb , _Ta ) # or # b) manually creating and attaching the provider container [ _Ta ] = xdi . providers . Alias ( _Ta ) obj = object () # bind `_Ta` to a constant `obj` container . value ( _Ta , obj ) if __name__ == '__main__' : injector = xdi . Injector ( xdi . Scope ( container )) assert obj is injector . make ( _Ta ) is injector . make ( _Tb ) In the above snippet, dependents of both _Tb and _Ta will be provided with obj .","title":"Alias Provider"},{"location":"providers/alias/#use-case","text":"import typing as t from xdi import Container , providers _Ta = t . TypeVar ( '_Ta' ) _Tb = t . TypeVar ( '_Tb' ) class Cache : ... class DbCache ( Cache ): ... class MemoryCache ( Cache ): ... class RedisCache ( Cache ): ... container = Container () container . singleton ( DbCache ) container . singleton ( RedisCache ) container . singleton ( MemoryCache ) container . alias ( Cache , RedisCache )","title":"Use Case"},{"location":"providers/callable/","text":"Callable Provider Provides a partial callable to a function, class, method or any other callable type 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import typing as t from xdi import Container , providers _T_PasswordHasher = t . TypeVar ( \"_T_PasswordHasher\" , bound = t . Callable [[ str ], str ]) def hash_password ( password : str , salt : str , rounds : int = 5000 , algo : t . Literal [ \"sha256\" , \"sha512\" , \"md5\" ] = \"md5\" , ): return \"hashed_password\" container = Container () container [ _T_PasswordHasher ] = providers . Callable ( hash_password , salt = \"my-secret\" , rounds = 1000 , algo = \"sha256\" ) # or use the helper method container . callable ( _T_PasswordHasher , hash_password , salt = \"my-secret\" , rounds = 1000 , algo = \"sha256\" )","title":"Callable Provider"},{"location":"providers/callable/#callable-provider","text":"Provides a partial callable to a function, class, method or any other callable type 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import typing as t from xdi import Container , providers _T_PasswordHasher = t . TypeVar ( \"_T_PasswordHasher\" , bound = t . Callable [[ str ], str ]) def hash_password ( password : str , salt : str , rounds : int = 5000 , algo : t . Literal [ \"sha256\" , \"sha512\" , \"md5\" ] = \"md5\" , ): return \"hashed_password\" container = Container () container [ _T_PasswordHasher ] = providers . Callable ( hash_password , salt = \"my-secret\" , rounds = 1000 , algo = \"sha256\" ) # or use the helper method container . callable ( _T_PasswordHasher , hash_password , salt = \"my-secret\" , rounds = 1000 , algo = \"sha256\" )","title":"Callable Provider"},{"location":"providers/custom/","text":"Create Custom Provider Available providers don't suite your needs? You can create a custom one.","title":"Create Custom Provider"},{"location":"providers/custom/#create-custom-provider","text":"Available providers don't suite your needs? You can create a custom one.","title":"Create Custom Provider"},{"location":"providers/factory/","text":"Factory Provider The Factory provider creates new objects every time it's requested. 1 2 3 4 5 6 7 8 9 10 from xdi import Container , providers class Service : ... container = Container () container . factory ( Service ) # or manually create the provider container [ Service ] = providers . Factory ( Service )","title":"Factory Provider"},{"location":"providers/factory/#factory-provider","text":"The Factory provider creates new objects every time it's requested. 1 2 3 4 5 6 7 8 9 10 from xdi import Container , providers class Service : ... container = Container () container . factory ( Service ) # or manually create the provider container [ Service ] = providers . Factory ( Service )","title":"Factory Provider"},{"location":"providers/implicit/","text":"Implicit Providers Annotated Types Support for typing.Annotated . . . Union Types Support for typing.Union . . . Dep Maker Support for xdi.Dep . . . x","title":"Implicit Providers"},{"location":"providers/implicit/#implicit-providers","text":"","title":"Implicit Providers"},{"location":"providers/implicit/#annotated-types","text":"Support for typing.Annotated . . .","title":"Annotated Types"},{"location":"providers/implicit/#union-types","text":"Support for typing.Union . . .","title":"Union Types"},{"location":"providers/implicit/#dep-maker","text":"Support for xdi.Dep . . . x","title":"Dep Maker"},{"location":"providers/resource/","text":"Resource Provider For services that have initialization and/or teardown stage(s).","title":"Resource Provider"},{"location":"providers/resource/#resource-provider","text":"For services that have initialization and/or teardown stage(s).","title":"Resource Provider"},{"location":"providers/singleton/","text":"Singleton Provider The Singleton provider creates and provides single object. It memorizes the first created object and returns it on the rest of the calls. 1 2 3 4 5 6 7 8 9 10 from xdi import Container , providers class Service : ... container = Container () container . singleton ( Service ) # or manually create the provider container [ Service ] = providers . Singleton ( Service )","title":"Singleton Provider"},{"location":"providers/singleton/#singleton-provider","text":"The Singleton provider creates and provides single object. It memorizes the first created object and returns it on the rest of the calls. 1 2 3 4 5 6 7 8 9 10 from xdi import Container , providers class Service : ... container = Container () container . singleton ( Service ) # or manually create the provider container [ Service ] = providers . Singleton ( Service )","title":"Singleton Provider"},{"location":"providers/value/","text":"Value Provider Provide given an object \"as is\". Simple Usage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from types import SimpleNamespace import xdi class Config ( SimpleNamespace ): debug : bool = False database : str config = Config ( debug = True , database = ':memory:' ) container = xdi . Container () # a) using the helper method container . value ( Config , config ) # or # b) manually creating and attaching the provider container [ Config ] = xdi . providers . Value ( config ) if __name__ == '__main__' : injector = xdi . Injector ( xdi . Scope ( container )) assert config == injector . make ( Config ) assert config is injector . make ( Config )","title":"Value Provider"},{"location":"providers/value/#value-provider","text":"Provide given an object \"as is\". Simple Usage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from types import SimpleNamespace import xdi class Config ( SimpleNamespace ): debug : bool = False database : str config = Config ( debug = True , database = ':memory:' ) container = xdi . Container () # a) using the helper method container . value ( Config , config ) # or # b) manually creating and attaching the provider container [ Config ] = xdi . providers . Value ( config ) if __name__ == '__main__' : injector = xdi . Injector ( xdi . Scope ( container )) assert config == injector . make ( Config ) assert config is injector . make ( Config )","title":"Value Provider"},{"location":"usage/00-introduction/","text":"Introduction Before we start, it would be good to introduce some core concepts used in xdi and across this documentation. Dependencies A dependency is an object which other objects require (depend on). In xdi a dependency is identified by it's type , a TypeVar or a DependencyMarker . Providers Providers define how a dependency is resolved. We use them to determine what happens when a dependency is requested. For example, they determine whether... - to create a new instance of dependency x for each request or to share one instance. - to uses a predefined constant or proxy another existing dependency and provide its value instead. Containers Containers are mappings of dependencies to their providers. We use them to bind dependencies to their providers. To allow for better modularity, containers can also include other containers . Scopes These are isolated dependency resolution contexts created from a set of containers. Scopes assemble the dependency graphs of dependencies registered in their containers. Injectors These are isolated dependency injection contexts for our scopes. They are responsible for assembling the object graphs of dependencies in a given scope.","title":"Introduction"},{"location":"usage/00-introduction/#introduction","text":"Before we start, it would be good to introduce some core concepts used in xdi and across this documentation.","title":"Introduction"},{"location":"usage/00-introduction/#dependencies","text":"A dependency is an object which other objects require (depend on). In xdi a dependency is identified by it's type , a TypeVar or a DependencyMarker .","title":"Dependencies"},{"location":"usage/00-introduction/#providers","text":"Providers define how a dependency is resolved. We use them to determine what happens when a dependency is requested. For example, they determine whether... - to create a new instance of dependency x for each request or to share one instance. - to uses a predefined constant or proxy another existing dependency and provide its value instead.","title":"Providers"},{"location":"usage/00-introduction/#containers","text":"Containers are mappings of dependencies to their providers. We use them to bind dependencies to their providers. To allow for better modularity, containers can also include other containers .","title":"Containers"},{"location":"usage/00-introduction/#scopes","text":"These are isolated dependency resolution contexts created from a set of containers. Scopes assemble the dependency graphs of dependencies registered in their containers.","title":"Scopes"},{"location":"usage/00-introduction/#injectors","text":"These are isolated dependency injection contexts for our scopes. They are responsible for assembling the object graphs of dependencies in a given scope.","title":"Injectors"},{"location":"usage/01-get-started/","text":"Getting Started This is an introductory tutorial on how to use xdi . Here we'll look at some simple examples on how you can use xdi whilst introducing you to some it's cool features. After this, you will be able to start using xdi in your projects.","title":"Getting Started"},{"location":"usage/01-get-started/#getting-started","text":"This is an introductory tutorial on how to use xdi . Here we'll look at some simple examples on how you can use xdi whilst introducing you to some it's cool features. After this, you will be able to start using xdi in your projects.","title":"Getting Started"}]}