{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"XDI XDI is a dependency injection library for Python. Why Use XDI? Fast: minus the cost of an additional stack frame, xdi resolves dependencies nearly as efficiently as resolving them by hand. Async support: xdi will await for you. Lots Providers to choose from. Why use dependency injection? Take a look at the following code. import os class ApiClient : def __init__ ( self ): self . api_url = os . getenv ( \"API_URL\" ) # a dependency self . api_key = os . getenv ( \"API_KEY\" ) # a dependency def get ( self , path : str , * , token : str ): return { url : f ' { self . api_url } / { path } ' , status : 'ok' , data : [] } class Service : def __init__ ( self ): self . _api_client = ApiClient () # a dependency # do some init def do_something ( self ): res = self . _api_client . get ( 'abc' ) print ( \"Service doing something\" ) def some_func ( * args , ** kwargs ) -> None : service = Service () # a dependency service . do_something () print ( \"serivce has done something\" ) if __name__ == \"__main__\" : some_func () This code will run as expected. However:- Testing it will be difficult For example, to test Service we need a fake ApiClient as we don't what to make real api calls or might not have the credentials to do so. Since Service creates it's own ApiClient instance, it is impossible to safely mock the ApiClient for tests. Lacks flexibility and extensibility It's imppossible to create an additional ApiClient instance that uses a different API_URL and/or API_KEY . So what do we do? We should decouple our objects from their dependencies. That is, objects should not create each other anymore. They should provide a way to inject the dependencies instead. Here's how. class ApiClient : def __init__ ( self , api_url : str , api_key : str ): # we let the caller provide the dependencies self . api_url , self . api_key = api_url , api_key class Service : def __init__ ( self , api_client : ApiClient ): # we let the caller provide the dependency self . _api_client = api_client def some_func ( * args , service : Service , ** params ): # we let the caller provide the dependency ... Congratulations, your code is now loosely coupled. But remember, with freedom comes more responsibility. The responsibility is left to the \"caller\" who has to know, assemble and provide the dependencies. some_func ( * args , service = Service ( api_client = ApiClient ( api_key = os . getenv ( \"API_KEY\" ), api_url = os . getenv ( \"TIMEOUT\" ), ), ), ** kwargs , ) This quickly becomes a problem when you what to use some_func() from multiple places. Duplicating the assembly code with make it harder to change in the future. With XDI. Simple DI using xdi 's low level API. from xdi import Injector , Scope , Container container = Container () # register the ApiClient container . singleton ( ApiClient , api_url = os . getenv ( \"API_URL\" ), # <-- provide value from env api_key = os . getenv ( 'API_KEY' ) # <-- provide value from env ) # <-- make it provide only one instance. # Register the Service. container . factory ( Service ) # Since we did not specify a value for api_client. `ApiClient` will get injected # as it matches the type annotation `api_client: ApiClient` # Create the scope scope = Scope ( container ) # Create an injector injector = Injector ( scope ) # Use the injector to run `some_func` result = injector . make ( some_func , 'xyz' , 23 , ** params ) # <-- dependency `Service` is injected automatically Installation Install from PyPi pip install xdi Documentation Full documentation is available here . Production This package is still in active development and should not be used in production environment","title":"XDI"},{"location":"#xdi","text":"XDI is a dependency injection library for Python.","title":"XDI"},{"location":"#why-use-xdi","text":"Fast: minus the cost of an additional stack frame, xdi resolves dependencies nearly as efficiently as resolving them by hand. Async support: xdi will await for you. Lots Providers to choose from.","title":"Why Use XDI?"},{"location":"#why-use-dependency-injection","text":"Take a look at the following code. import os class ApiClient : def __init__ ( self ): self . api_url = os . getenv ( \"API_URL\" ) # a dependency self . api_key = os . getenv ( \"API_KEY\" ) # a dependency def get ( self , path : str , * , token : str ): return { url : f ' { self . api_url } / { path } ' , status : 'ok' , data : [] } class Service : def __init__ ( self ): self . _api_client = ApiClient () # a dependency # do some init def do_something ( self ): res = self . _api_client . get ( 'abc' ) print ( \"Service doing something\" ) def some_func ( * args , ** kwargs ) -> None : service = Service () # a dependency service . do_something () print ( \"serivce has done something\" ) if __name__ == \"__main__\" : some_func () This code will run as expected. However:- Testing it will be difficult For example, to test Service we need a fake ApiClient as we don't what to make real api calls or might not have the credentials to do so. Since Service creates it's own ApiClient instance, it is impossible to safely mock the ApiClient for tests. Lacks flexibility and extensibility It's imppossible to create an additional ApiClient instance that uses a different API_URL and/or API_KEY . So what do we do? We should decouple our objects from their dependencies. That is, objects should not create each other anymore. They should provide a way to inject the dependencies instead. Here's how. class ApiClient : def __init__ ( self , api_url : str , api_key : str ): # we let the caller provide the dependencies self . api_url , self . api_key = api_url , api_key class Service : def __init__ ( self , api_client : ApiClient ): # we let the caller provide the dependency self . _api_client = api_client def some_func ( * args , service : Service , ** params ): # we let the caller provide the dependency ... Congratulations, your code is now loosely coupled. But remember, with freedom comes more responsibility. The responsibility is left to the \"caller\" who has to know, assemble and provide the dependencies. some_func ( * args , service = Service ( api_client = ApiClient ( api_key = os . getenv ( \"API_KEY\" ), api_url = os . getenv ( \"TIMEOUT\" ), ), ), ** kwargs , ) This quickly becomes a problem when you what to use some_func() from multiple places. Duplicating the assembly code with make it harder to change in the future.","title":"Why use dependency injection?"},{"location":"#with-xdi","text":"Simple DI using xdi 's low level API. from xdi import Injector , Scope , Container container = Container () # register the ApiClient container . singleton ( ApiClient , api_url = os . getenv ( \"API_URL\" ), # <-- provide value from env api_key = os . getenv ( 'API_KEY' ) # <-- provide value from env ) # <-- make it provide only one instance. # Register the Service. container . factory ( Service ) # Since we did not specify a value for api_client. `ApiClient` will get injected # as it matches the type annotation `api_client: ApiClient` # Create the scope scope = Scope ( container ) # Create an injector injector = Injector ( scope ) # Use the injector to run `some_func` result = injector . make ( some_func , 'xyz' , 23 , ** params ) # <-- dependency `Service` is injected automatically","title":"With XDI."},{"location":"#installation","text":"Install from PyPi pip install xdi","title":"Installation"},{"location":"#documentation","text":"Full documentation is available here .","title":"Documentation"},{"location":"#production","text":"This package is still in active development and should not be used in production environment","title":"Production"},{"location":"basic_usage/","text":"Basic Usage Installation Install from PyPi pip install xdi","title":"Basic Usage"},{"location":"basic_usage/#basic-usage","text":"","title":"Basic Usage"},{"location":"basic_usage/#installation","text":"Install from PyPi pip install xdi","title":"Installation"},{"location":"providers/","text":"Providers Value Provider Factory Provider Singleton Provider Resource Provider Callable Provider Alias Provider Implicit Providers Annotated Types Union Types Dep Marker","title":"Providers"},{"location":"providers/#providers","text":"Value Provider Factory Provider Singleton Provider Resource Provider Callable Provider Alias Provider Implicit Providers Annotated Types Union Types Dep Marker","title":"Providers"},{"location":"providers/alias/","text":"Alias Provider Used to \"alias\" another existing dependency. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import typing as t from xdi import Container , providers _Ta = t . TypeVar ( '_Ta' ) _Tb = t . TypeVar ( '_Tb' ) container = Container () container [ _Ta ] = providers . Alias ( _Ta ) # or use the helper method container . alias ( _Tb , _Ta ) obj = object () # bind `_Ta` to object `obj` container . value ( _Ta , obj ) In the above snippet, dependents of both _Tb and _Ta will be provided with obj . Use Case import typing as t from xdi import Container , providers _Ta = t . TypeVar ( '_Ta' ) _Tb = t . TypeVar ( '_Tb' ) class Cache : ... class DbCache ( Cache ): ... class MemoryCache ( Cache ): ... class RedisCache ( Cache ): ... container = Container () container . singleton ( DbCache ) container . singleton ( RedisCache ) container . singleton ( MemoryCache ) container . alias ( Cache , RedisCache )","title":"Alias Provider"},{"location":"providers/alias/#alias-provider","text":"Used to \"alias\" another existing dependency. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import typing as t from xdi import Container , providers _Ta = t . TypeVar ( '_Ta' ) _Tb = t . TypeVar ( '_Tb' ) container = Container () container [ _Ta ] = providers . Alias ( _Ta ) # or use the helper method container . alias ( _Tb , _Ta ) obj = object () # bind `_Ta` to object `obj` container . value ( _Ta , obj ) In the above snippet, dependents of both _Tb and _Ta will be provided with obj .","title":"Alias Provider"},{"location":"providers/alias/#use-case","text":"import typing as t from xdi import Container , providers _Ta = t . TypeVar ( '_Ta' ) _Tb = t . TypeVar ( '_Tb' ) class Cache : ... class DbCache ( Cache ): ... class MemoryCache ( Cache ): ... class RedisCache ( Cache ): ... container = Container () container . singleton ( DbCache ) container . singleton ( RedisCache ) container . singleton ( MemoryCache ) container . alias ( Cache , RedisCache )","title":"Use Case"},{"location":"providers/callable/","text":"Callable Provider Provides a partial callable to a function, class, method or any other callable type 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import typing as t from xdi import Container , providers _T_PasswordHasher = t . TypeVar ( \"_T_PasswordHasher\" , bound = t . Callable [[ str ], str ]) def hash_password ( password : str , salt : str , rounds : int = 5000 , algo : t . Literal [ \"sha256\" , \"sha512\" , \"md5\" ] = \"md5\" , ): return \"hashed_password\" container = Container () container [ _T_PasswordHasher ] = providers . Callable ( hash_password , salt = \"my-secret\" , rounds = 1000 , algo = \"sha256\" ) # or use the helper method container . callable ( _T_PasswordHasher , hash_password , salt = \"my-secret\" , rounds = 1000 , algo = \"sha256\" )","title":"Callable Provider"},{"location":"providers/callable/#callable-provider","text":"Provides a partial callable to a function, class, method or any other callable type 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import typing as t from xdi import Container , providers _T_PasswordHasher = t . TypeVar ( \"_T_PasswordHasher\" , bound = t . Callable [[ str ], str ]) def hash_password ( password : str , salt : str , rounds : int = 5000 , algo : t . Literal [ \"sha256\" , \"sha512\" , \"md5\" ] = \"md5\" , ): return \"hashed_password\" container = Container () container [ _T_PasswordHasher ] = providers . Callable ( hash_password , salt = \"my-secret\" , rounds = 1000 , algo = \"sha256\" ) # or use the helper method container . callable ( _T_PasswordHasher , hash_password , salt = \"my-secret\" , rounds = 1000 , algo = \"sha256\" )","title":"Callable Provider"},{"location":"providers/factory/","text":"Factory Provider The Factory provider creates new objects every time it's requested. 1 2 3 4 5 6 7 8 9 10 from xdi import Container , providers class Service : ... container = Container () container . factory ( Service ) # or manually create the provider container [ Service ] = providers . Factory ( Service )","title":"Factory Provider"},{"location":"providers/factory/#factory-provider","text":"The Factory provider creates new objects every time it's requested. 1 2 3 4 5 6 7 8 9 10 from xdi import Container , providers class Service : ... container = Container () container . factory ( Service ) # or manually create the provider container [ Service ] = providers . Factory ( Service )","title":"Factory Provider"},{"location":"providers/implicit/","text":"Implicit Providers Annotated Types Support for typing.Annotated . . . Union Types Support for typing.Union . . . Dep Maker Support for xdi.Dep . . . x","title":"Implicit Providers"},{"location":"providers/implicit/#implicit-providers","text":"","title":"Implicit Providers"},{"location":"providers/implicit/#annotated-types","text":"Support for typing.Annotated . . .","title":"Annotated Types"},{"location":"providers/implicit/#union-types","text":"Support for typing.Union . . .","title":"Union Types"},{"location":"providers/implicit/#dep-maker","text":"Support for xdi.Dep . . . x","title":"Dep Maker"},{"location":"providers/resource/","text":"Resource Provider For services that have initialization and/or teardown stage(s).","title":"Resource Provider"},{"location":"providers/resource/#resource-provider","text":"For services that have initialization and/or teardown stage(s).","title":"Resource Provider"},{"location":"providers/singleton/","text":"Singleton Provider The Singleton provider creates and provides single object. It memorizes the first created object and returns it on the rest of the calls. 1 2 3 4 5 6 7 8 9 10 from xdi import Container , providers class Service : ... container = Container () container . singleton ( Service ) # or manually create the provider container [ Service ] = providers . Singleton ( Service )","title":"Singleton Provider"},{"location":"providers/singleton/#singleton-provider","text":"The Singleton provider creates and provides single object. It memorizes the first created object and returns it on the rest of the calls. 1 2 3 4 5 6 7 8 9 10 from xdi import Container , providers class Service : ... container = Container () container . singleton ( Service ) # or manually create the provider container [ Service ] = providers . Singleton ( Service )","title":"Singleton Provider"},{"location":"providers/value/","text":"Value Provider Provide given an object \"as is\". 1 2 3 4 5 6 7 8 9 10 11 import typing as t from xdi import Container , providers _T_Str = t . TypeVar ( '_T_Str' , str ) container = Container () # Will provide 'xyz' to the dependants of _T_Str container [ _T_Str ] = providers . Value ( 'xyz' ) # or use the helper method container . value ( _T_Str , 'abc' )","title":"Value Provider"},{"location":"providers/value/#value-provider","text":"Provide given an object \"as is\". 1 2 3 4 5 6 7 8 9 10 11 import typing as t from xdi import Container , providers _T_Str = t . TypeVar ( '_T_Str' , str ) container = Container () # Will provide 'xyz' to the dependants of _T_Str container [ _T_Str ] = providers . Value ( 'xyz' ) # or use the helper method container . value ( _T_Str , 'abc' )","title":"Value Provider"}]}