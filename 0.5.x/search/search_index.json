{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Introduction \u00b6 XDI is a dependency injection library for Python. Why Use XDI? \u00b6 Fast: minus the cost of an additional stack frame, xdi resolves dependencies nearly as efficiently as resolving them by hand. Async support: xdi will await for you. Lots Providers to choose from. Why use dependency injection? \u00b6 Take a look at the following code. import os class ApiClient : def __init__ ( self ): self . api_url = os . getenv ( \"API_URL\" ) # a dependency self . api_key = os . getenv ( \"API_KEY\" ) # a dependency def get ( self , path : str , * , token : str ): return { url : f ' { self . api_url } / { path } ' , status : 'ok' , data : [] } class Service : def __init__ ( self ): self . _api_client = ApiClient () # a dependency # do some init def do_something ( self ): res = self . _api_client . get ( 'abc' ) print ( \"Service doing something\" ) def some_func ( * args , ** kwargs ) -> None : service = Service () # a dependency service . do_something () print ( \"serivce has done something\" ) if __name__ == \"__main__\" : some_func () This code will run as expected. However:- Testing it will be difficult For example, to test Service we need a fake ApiClient as we don't what to make real api calls or might not have the credentials to do so. Since Service creates it's own ApiClient instance, it is impossible to safely mock the ApiClient for tests. Lacks flexibility and extensibility It's imppossible to create an additional ApiClient instance that uses a different API_URL and/or API_KEY . So what do we do? We should decouple our objects from their dependencies. That is, objects should not create each other anymore. They should provide a way to inject the dependencies instead. Here's how. class ApiClient : def __init__ ( self , api_url : str , api_key : str ): # we let the caller provide the dependencies self . api_url , self . api_key = api_url , api_key class Service : def __init__ ( self , api_client : ApiClient ): # we let the caller provide the dependency self . _api_client = api_client def some_func ( * args , service : Service , ** params ): # we let the caller provide the dependency ... Congratulations, your code is now loosely coupled. But remember, with freedom comes more responsibility. The responsibility is left to the \"caller\" who has to know, assemble and provide the dependencies. some_func ( * args , service = Service ( api_client = ApiClient ( api_key = os . getenv ( \"API_KEY\" ), api_url = os . getenv ( \"TIMEOUT\" ), ), ), ** kwargs , ) This quickly becomes a problem when you what to use some_func() from multiple places. Duplicating the assembly code with make it harder to change in the future. With XDI. \u00b6 Simple DI using xdi 's low level API. from xdi import Injector , Scope , Container container = Container () # register the ApiClient container . singleton ( ApiClient , api_url = os . getenv ( \"API_URL\" ), # <-- provide value from env api_key = os . getenv ( 'API_KEY' ) # <-- provide value from env ) # <-- make it provide only one instance. # Register the Service. container . factory ( Service ) # Since we did not specify a value for api_client. `ApiClient` will get injected # as it matches the type annotation `api_client: ApiClient` # Create the scope scope = Scope ( container ) # Create an injector injector = Injector ( scope ) # Use the injector to run `some_func` result = injector . make ( some_func , 'xyz' , 23 , ** params ) # <-- dependency `Service` is injected automatically Installation \u00b6 Install from PyPi pip install xdi Documentation \u00b6 Full documentation is available here . Production \u00b6 This package is still in active development and should not be used in production environment","title":"Home"},{"location":"index.html#introduction","text":"XDI is a dependency injection library for Python.","title":"Introduction"},{"location":"index.html#why-use-xdi","text":"Fast: minus the cost of an additional stack frame, xdi resolves dependencies nearly as efficiently as resolving them by hand. Async support: xdi will await for you. Lots Providers to choose from.","title":"Why Use XDI?"},{"location":"index.html#why-use-dependency-injection","text":"Take a look at the following code. import os class ApiClient : def __init__ ( self ): self . api_url = os . getenv ( \"API_URL\" ) # a dependency self . api_key = os . getenv ( \"API_KEY\" ) # a dependency def get ( self , path : str , * , token : str ): return { url : f ' { self . api_url } / { path } ' , status : 'ok' , data : [] } class Service : def __init__ ( self ): self . _api_client = ApiClient () # a dependency # do some init def do_something ( self ): res = self . _api_client . get ( 'abc' ) print ( \"Service doing something\" ) def some_func ( * args , ** kwargs ) -> None : service = Service () # a dependency service . do_something () print ( \"serivce has done something\" ) if __name__ == \"__main__\" : some_func () This code will run as expected. However:- Testing it will be difficult For example, to test Service we need a fake ApiClient as we don't what to make real api calls or might not have the credentials to do so. Since Service creates it's own ApiClient instance, it is impossible to safely mock the ApiClient for tests. Lacks flexibility and extensibility It's imppossible to create an additional ApiClient instance that uses a different API_URL and/or API_KEY . So what do we do? We should decouple our objects from their dependencies. That is, objects should not create each other anymore. They should provide a way to inject the dependencies instead. Here's how. class ApiClient : def __init__ ( self , api_url : str , api_key : str ): # we let the caller provide the dependencies self . api_url , self . api_key = api_url , api_key class Service : def __init__ ( self , api_client : ApiClient ): # we let the caller provide the dependency self . _api_client = api_client def some_func ( * args , service : Service , ** params ): # we let the caller provide the dependency ... Congratulations, your code is now loosely coupled. But remember, with freedom comes more responsibility. The responsibility is left to the \"caller\" who has to know, assemble and provide the dependencies. some_func ( * args , service = Service ( api_client = ApiClient ( api_key = os . getenv ( \"API_KEY\" ), api_url = os . getenv ( \"TIMEOUT\" ), ), ), ** kwargs , ) This quickly becomes a problem when you what to use some_func() from multiple places. Duplicating the assembly code with make it harder to change in the future.","title":"Why use dependency injection?"},{"location":"index.html#with-xdi","text":"Simple DI using xdi 's low level API. from xdi import Injector , Scope , Container container = Container () # register the ApiClient container . singleton ( ApiClient , api_url = os . getenv ( \"API_URL\" ), # <-- provide value from env api_key = os . getenv ( 'API_KEY' ) # <-- provide value from env ) # <-- make it provide only one instance. # Register the Service. container . factory ( Service ) # Since we did not specify a value for api_client. `ApiClient` will get injected # as it matches the type annotation `api_client: ApiClient` # Create the scope scope = Scope ( container ) # Create an injector injector = Injector ( scope ) # Use the injector to run `some_func` result = injector . make ( some_func , 'xyz' , 23 , ** params ) # <-- dependency `Service` is injected automatically","title":"With XDI."},{"location":"index.html#installation","text":"Install from PyPi pip install xdi","title":"Installation"},{"location":"index.html#documentation","text":"Full documentation is available here .","title":"Documentation"},{"location":"index.html#production","text":"This package is still in active development and should not be used in production environment","title":"Production"},{"location":"concepts.html","text":"Key Concepts \u00b6 Before we start, it would be good to introduce some core concepts used in xdi and across this documentation. Dependencies \u00b6 A dependency is an object which other objects require (depend on). In xdi a dependency is identified by it's type , a TypeVar or a DependencyMarker . Providers \u00b6 Providers define how a dependency is resolved. We use them to determine what happens when a dependency is requested. For example, they determine whether... - to create a new instance of dependency x for each request or to share one instance. - to uses a predefined constant or proxy another existing dependency and provide its value instead. Containers \u00b6 Containers are mappings of dependencies to their providers. We use them to bind dependencies to their providers. To allow for better modularity, containers can also include other containers . Scopes \u00b6 These are isolated dependency resolution contexts created from a set of containers. Scopes assemble the dependency graphs of dependencies registered in their containers. Injectors \u00b6 These are isolated dependency injection contexts for our scopes. They are responsible for assembling the object graphs of dependencies in a given scope.","title":"Key Concepts"},{"location":"concepts.html#key-concepts","text":"Before we start, it would be good to introduce some core concepts used in xdi and across this documentation.","title":"Key Concepts"},{"location":"concepts.html#dependencies","text":"A dependency is an object which other objects require (depend on). In xdi a dependency is identified by it's type , a TypeVar or a DependencyMarker .","title":"Dependencies"},{"location":"concepts.html#providers","text":"Providers define how a dependency is resolved. We use them to determine what happens when a dependency is requested. For example, they determine whether... - to create a new instance of dependency x for each request or to share one instance. - to uses a predefined constant or proxy another existing dependency and provide its value instead.","title":"Providers"},{"location":"concepts.html#containers","text":"Containers are mappings of dependencies to their providers. We use them to bind dependencies to their providers. To allow for better modularity, containers can also include other containers .","title":"Containers"},{"location":"concepts.html#scopes","text":"These are isolated dependency resolution contexts created from a set of containers. Scopes assemble the dependency graphs of dependencies registered in their containers.","title":"Scopes"},{"location":"concepts.html#injectors","text":"These are isolated dependency injection contexts for our scopes. They are responsible for assembling the object graphs of dependencies in a given scope.","title":"Injectors"},{"location":"contributing.html","text":"Contributing \u00b6 Environment Setup \u00b6 We Poetry for package management. Documentation \u00b6 Contributing documentation","title":"Contributing"},{"location":"contributing.html#contributing","text":"","title":"Contributing"},{"location":"contributing.html#environment-setup","text":"We Poetry for package management.","title":"Environment Setup"},{"location":"contributing.html#documentation","text":"Contributing documentation","title":"Documentation"},{"location":"features.html","text":"Why Use XDI \u00b6 Before we start, it would be good to introduce some core concepts used in xdi and across this documentation. Dependencies \u00b6 A dependency is an object which other objects require (depend on). In xdi a dependency is identified by it's type , a TypeVar or a DependencyMarker . Providers \u00b6 Providers define how a dependency is resolved. We use them to determine what happens when a dependency is requested. For example, they determine whether... - to create a new instance of dependency x for each request or to share one instance. - to uses a predefined constant or proxy another existing dependency and provide its value instead. Containers \u00b6 Containers are mappings of dependencies to their providers. We use them to bind dependencies to their providers. To allow for better modularity, containers can also include other containers . Scopes \u00b6 These are isolated dependency resolution contexts created from a set of containers. Scopes assemble the dependency graphs of dependencies registered in their containers. Injectors \u00b6 These are isolated dependency injection contexts for our scopes. They are responsible for assembling the object graphs of dependencies in a given scope.","title":"Why Use XDI"},{"location":"features.html#why-use-xdi","text":"Before we start, it would be good to introduce some core concepts used in xdi and across this documentation.","title":"Why Use XDI"},{"location":"features.html#dependencies","text":"A dependency is an object which other objects require (depend on). In xdi a dependency is identified by it's type , a TypeVar or a DependencyMarker .","title":"Dependencies"},{"location":"features.html#providers","text":"Providers define how a dependency is resolved. We use them to determine what happens when a dependency is requested. For example, they determine whether... - to create a new instance of dependency x for each request or to share one instance. - to uses a predefined constant or proxy another existing dependency and provide its value instead.","title":"Providers"},{"location":"features.html#containers","text":"Containers are mappings of dependencies to their providers. We use them to bind dependencies to their providers. To allow for better modularity, containers can also include other containers .","title":"Containers"},{"location":"features.html#scopes","text":"These are isolated dependency resolution contexts created from a set of containers. Scopes assemble the dependency graphs of dependencies registered in their containers.","title":"Scopes"},{"location":"features.html#injectors","text":"These are isolated dependency injection contexts for our scopes. They are responsible for assembling the object graphs of dependencies in a given scope.","title":"Injectors"},{"location":"install.html","text":"Installation \u00b6 Supported Python Versions \u00b6 xdi only supports python 3.9 or higher. Support for python 3.8 might be added in the near future. Standalone \u00b6 xdi is available on PyPi . To install, run:- pip install xdi Integrated \u00b6 xdi provides seamless integrations with some popular python frameworks like Django , Sanic and many more... . To use xdi with your favorite framework, you will need to install the appropriate adapter for that framework. For more information please refer to the intergration docs .","title":"Installation"},{"location":"install.html#installation","text":"","title":"Installation"},{"location":"install.html#supported-python-versions","text":"xdi only supports python 3.9 or higher. Support for python 3.8 might be added in the near future.","title":"Supported Python Versions"},{"location":"install.html#standalone","text":"xdi is available on PyPi . To install, run:- pip install xdi","title":"Standalone"},{"location":"install.html#integrated","text":"xdi provides seamless integrations with some popular python frameworks like Django , Sanic and many more... . To use xdi with your favorite framework, you will need to install the appropriate adapter for that framework. For more information please refer to the intergration docs .","title":"Integrated"},{"location":"advanced/index.html","text":"Advanced Usage \u00b6","title":"Advanced Usage"},{"location":"advanced/index.html#advanced-usage","text":"","title":"Advanced Usage"},{"location":"advanced/containers.html","text":"Containers \u00b6 Containers are mappings of dependencies to their providers.","title":"Containers"},{"location":"advanced/containers.html#containers","text":"Containers are mappings of dependencies to their providers.","title":"Containers"},{"location":"advanced/scopes.html","text":"Scopes \u00b6","title":"Scopes"},{"location":"advanced/scopes.html#scopes","text":"","title":"Scopes"},{"location":"api/_bindings.html","text":"Bindings \u00b6 xdi._bindings \u00b6 _T_Concrete = t . TypeVar ( '_T_Concrete' ) module-attribute \u00b6 Provided concrete TypeVar _T_Binding = t . TypeVar ( '_T_Binding' , bound = Binding , covariant = True ) module-attribute \u00b6 Dependency TypeVar _T_ValueBinding = t . TypeVar ( '_T_ValueBinding' , bound = Value , covariant = True ) module-attribute \u00b6 Value binding TypeVar _T_FactoryBinding = t . TypeVar ( '_T_FactoryBinding' , bound = Factory , covariant = True ) module-attribute \u00b6 Factory binding TypeVar _T_SingletonBinding = t . TypeVar ( '_T_SingletonBinding' , bound = Singleton , covariant = True ) module-attribute \u00b6 Singleton binding TypeVar _T_ResourceBinding = t . TypeVar ( '_T_ResourceBinding' , bound = Resource , covariant = True ) module-attribute \u00b6 Resource binding TypeVar _T_PartialBinding = t . TypeVar ( '_T_PartialBinding' , bound = Partial , covariant = True ) module-attribute \u00b6 Partial binding TypeVar _T_CallableBinding = t . TypeVar ( '_T_CallableBinding' , bound = Callable , covariant = True ) module-attribute \u00b6 Callable binding TypeVar Binding \u00b6 Bases: ABC , t . Generic [ _T_Concrete ] Marks binding an injectable as a dependency to be injected. Resource \u00b6 Bases: Singleton [ T_Injected ] Binds resources.","title":"xdi._bindings"},{"location":"api/_bindings.html#bindings","text":"","title":"Bindings"},{"location":"api/_bindings.html#xdi._bindings","text":"","title":"_bindings"},{"location":"api/_bindings.html#xdi._bindings._T_Concrete","text":"Provided concrete TypeVar","title":"_T_Concrete"},{"location":"api/_bindings.html#xdi._bindings._T_Binding","text":"Dependency TypeVar","title":"_T_Binding"},{"location":"api/_bindings.html#xdi._bindings._T_ValueBinding","text":"Value binding TypeVar","title":"_T_ValueBinding"},{"location":"api/_bindings.html#xdi._bindings._T_FactoryBinding","text":"Factory binding TypeVar","title":"_T_FactoryBinding"},{"location":"api/_bindings.html#xdi._bindings._T_SingletonBinding","text":"Singleton binding TypeVar","title":"_T_SingletonBinding"},{"location":"api/_bindings.html#xdi._bindings._T_ResourceBinding","text":"Resource binding TypeVar","title":"_T_ResourceBinding"},{"location":"api/_bindings.html#xdi._bindings._T_PartialBinding","text":"Partial binding TypeVar","title":"_T_PartialBinding"},{"location":"api/_bindings.html#xdi._bindings._T_CallableBinding","text":"Callable binding TypeVar","title":"_T_CallableBinding"},{"location":"api/_bindings.html#xdi._bindings.Binding","text":"Bases: ABC , t . Generic [ _T_Concrete ] Marks binding an injectable as a dependency to be injected.","title":"Binding"},{"location":"api/_bindings.html#xdi._bindings.Resource","text":"Bases: Singleton [ T_Injected ] Binds resources.","title":"Resource"},{"location":"api/_common.html","text":"Common \u00b6 xdi._common \u00b6 FrozenDict \u00b6 Bases: dict [ _T_Key , _T_Val ] An immutable and hashable dict . lookups \u00b6 Lookup \u00b6 Bases: Expression [ tuple [ Expression [ t . Any , _T_Obj ]], _T_Obj ] , t . Generic [ _T_Obj ] A chain of lookup experesions. xdi._common.lookups \u00b6 Lookup \u00b6 Bases: Expression [ tuple [ Expression [ t . Any , _T_Obj ]], _T_Obj ] , t . Generic [ _T_Obj ] A chain of lookup experesions.","title":"xdi._common"},{"location":"api/_common.html#common","text":"","title":"Common"},{"location":"api/_common.html#xdi._common","text":"","title":"_common"},{"location":"api/_common.html#xdi._common.FrozenDict","text":"Bases: dict [ _T_Key , _T_Val ] An immutable and hashable dict .","title":"FrozenDict"},{"location":"api/_common.html#xdi._common.lookups","text":"","title":"lookups"},{"location":"api/_common.html#xdi._common.lookups.Lookup","text":"Bases: Expression [ tuple [ Expression [ t . Any , _T_Obj ]], _T_Obj ] , t . Generic [ _T_Obj ] A chain of lookup experesions.","title":"Lookup"},{"location":"api/_common.html#xdi._common.lookups","text":"","title":"lookups"},{"location":"api/_common.html#xdi._common.lookups.Lookup","text":"Bases: Expression [ tuple [ Expression [ t . Any , _T_Obj ]], _T_Obj ] , t . Generic [ _T_Obj ] A chain of lookup experesions.","title":"Lookup"},{"location":"api/_functools.html","text":"Functools \u00b6 xdi._functools \u00b6 BoundParam \u00b6 A bound param BoundParams \u00b6 A collection of bound params","title":"xdi._functools"},{"location":"api/_functools.html#functools","text":"","title":"Functools"},{"location":"api/_functools.html#xdi._functools","text":"","title":"_functools"},{"location":"api/_functools.html#xdi._functools.BoundParam","text":"A bound param","title":"BoundParam"},{"location":"api/_functools.html#xdi._functools.BoundParams","text":"A collection of bound params","title":"BoundParams"},{"location":"api/containers.html","text":"Containers \u00b6 xdi.containers \u00b6 Container \u00b6 Bases: AbstractProviderRegistry , FrozenDict [ Injectable , Provider ] A mapping of dependencies to their providers. We use them to bind dependencies to their providers. Attributes: Name Type Description name str The container's name bases tuple [ Container ] The container's bases Parameters: Name Type Description Default name str Name of the container required bases tuple [ Container ] Base container. required pro () -> tuple [ Self ] property \u00b6 The container's provider resolution order. Like python's class __mro__ the pro is computed using C3 linearization Returns: Name Type Description pro tuple [ Container ] extend ( * bases : Self ) -> Self \u00b6 Adds containers to extended by this container. Parameters: Name Type Description Default *bases Container The base containers to be extended () Returns: Name Type Description Self Self this container extends ( other : Self ) -> bool \u00b6 Check whether this container extends the given base. Parameters: Name Type Description Default base Container The base container to check required Returns: Name Type Description bool bool __setitem__ ( abstract : Injectable , provider : Provider ) -> Self \u00b6 Register a dependency provider container[_T] = providers.Value('abc') Parameters: Name Type Description Default abstract Injectable The dependency to be provided required provider Provider The provider to provide the dependency required","title":"xdi.containers"},{"location":"api/containers.html#containers","text":"","title":"Containers"},{"location":"api/containers.html#xdi.containers","text":"","title":"containers"},{"location":"api/containers.html#xdi.containers.Container","text":"Bases: AbstractProviderRegistry , FrozenDict [ Injectable , Provider ] A mapping of dependencies to their providers. We use them to bind dependencies to their providers. Attributes: Name Type Description name str The container's name bases tuple [ Container ] The container's bases Parameters: Name Type Description Default name str Name of the container required bases tuple [ Container ] Base container. required","title":"Container"},{"location":"api/containers.html#xdi.containers.Container.pro","text":"The container's provider resolution order. Like python's class __mro__ the pro is computed using C3 linearization Returns: Name Type Description pro tuple [ Container ]","title":"pro()"},{"location":"api/containers.html#xdi.containers.Container.extend","text":"Adds containers to extended by this container. Parameters: Name Type Description Default *bases Container The base containers to be extended () Returns: Name Type Description Self Self this container","title":"extend()"},{"location":"api/containers.html#xdi.containers.Container.extends","text":"Check whether this container extends the given base. Parameters: Name Type Description Default base Container The base container to check required Returns: Name Type Description bool bool","title":"extends()"},{"location":"api/containers.html#xdi.containers.Container.__setitem__","text":"Register a dependency provider container[_T] = providers.Value('abc') Parameters: Name Type Description Default abstract Injectable The dependency to be provided required provider Provider The provider to provide the dependency required","title":"__setitem__()"},{"location":"api/core.html","text":"core \u00b6 xdi.core \u00b6 T_Injected = t . TypeVar ( 'T_Injected' , covariant = True ) module-attribute \u00b6 The injected type. T_Default = t . TypeVar ( 'T_Default' ) module-attribute \u00b6 Default value type. T_Injectable = t . TypeVar ( 'T_Injectable' , bound = 'Injectable' , covariant = True ) module-attribute \u00b6 An Injectable type. InjectorLookupError \u00b6 Bases: KeyError Raised by ~Injector` when a missing dependency is requested. Parameters: Name Type Description Default abstract Injectable the missing dependency required Injectable \u00b6 Abstract base class for injectable types. An injectable is an object that can be used to represent a dependency. Builtin injectable types:- type , TypeVar , FunctionType , MethodType , GenericAlias is_injectable ( obj ) \u00b6 Returns True if the given type annotation is injectable. Params: typ (type): The type annotation to check. Returns: Type Description bool True if typ can be injected or False if otherwise. is_injectable_annotation ( typ ) \u00b6 Returns True if the given type annotation is injectable. Params: typ (type): The type annotation to check. Returns: Type Description bool True if typ can be injected or False if otherwise.","title":"xdi.core"},{"location":"api/core.html#core","text":"","title":"core"},{"location":"api/core.html#xdi.core","text":"","title":"core"},{"location":"api/core.html#xdi.core.T_Injected","text":"The injected type.","title":"T_Injected"},{"location":"api/core.html#xdi.core.T_Default","text":"Default value type.","title":"T_Default"},{"location":"api/core.html#xdi.core.T_Injectable","text":"An Injectable type.","title":"T_Injectable"},{"location":"api/core.html#xdi.core.InjectorLookupError","text":"Bases: KeyError Raised by ~Injector` when a missing dependency is requested. Parameters: Name Type Description Default abstract Injectable the missing dependency required","title":"InjectorLookupError"},{"location":"api/core.html#xdi.core.Injectable","text":"Abstract base class for injectable types. An injectable is an object that can be used to represent a dependency. Builtin injectable types:- type , TypeVar , FunctionType , MethodType , GenericAlias","title":"Injectable"},{"location":"api/core.html#xdi.core.is_injectable","text":"Returns True if the given type annotation is injectable. Params: typ (type): The type annotation to check. Returns: Type Description bool True if typ can be injected or False if otherwise.","title":"is_injectable()"},{"location":"api/core.html#xdi.core.is_injectable_annotation","text":"Returns True if the given type annotation is injectable. Params: typ (type): The type annotation to check. Returns: Type Description bool True if typ can be injected or False if otherwise.","title":"is_injectable_annotation()"},{"location":"api/injectors.html","text":"Injectors \u00b6 xdi.injectors \u00b6 Injector \u00b6 Bases: FrozenDict [ T_Injectable , Callable [[], T_Injected ]] An isolated dependency injection context for a given Scope . Attributes: Name Type Description scope Scope the scope for this injector parent Injector a parent injector to provide missing dependencies. Parameters: Name Type Description Default scope Scope the scope for this injector required parent Injector a parent injector to provide missing dependencies. None name () -> str property \u00b6 The name of the scope. Usually returns the injector's scope.name NullInjector \u00b6 Bases: Injector A 'noop' Injector used as the parent of root injectors. Attributes: Name Type Description scope NullScope the scope parent None The parent injector _InjectorExitStack \u00b6 Bases: list [ tuple [ bool , _T_Fn ]] Async context manager for dynamic management of a stack of exit callbacks. For example async with AsyncExitStack() as stack: connections = [await stack.enter_async_context(get_connection()) for i in range(5)] # All opened connections will automatically be released at the # end of the async with statement, even if attempts to open a # connection later in the list raise an exception. push ( exit : _T ) -> _T \u00b6 Registers a callback with the standard exit method signature. Can suppress exceptions the same way exit method can. Also accepts any object with an exit method (registering a call to the method instead of the object itself). enter ( cm ) \u00b6 Enters the supplied context manager. If successful, also pushes its exit method as a callback and returns the result of the enter method. callback ( / , callback : _T_Fn , * args , ** kwds ) -> _T_Fn \u00b6 Registers an arbitrary callback and arguments. Cannot suppress exceptions. close () \u00b6 Immediately unwind the context stack. enter_async ( cm ) async \u00b6 Enters the supplied async context manager. If successful, also pushes its aexit method as a callback and returns the result of the aenter method. push_async_exit ( exit ) \u00b6 Registers a coroutine function with the standard aexit method signature. Can suppress exceptions the same way aexit method can. Also accepts any object with an aexit method (registering a call to the method instead of the object itself). callback_async ( / , callback , * args , ** kwds ) \u00b6 Registers an arbitrary coroutine function and arguments. Cannot suppress exceptions. aclose () async \u00b6 Immediately unwind the context stack. _push_async_cm_exit ( cm , cm_exit ) \u00b6 Helper to correctly register coroutine function to aexit method.","title":"xdi.injectors"},{"location":"api/injectors.html#injectors","text":"","title":"Injectors"},{"location":"api/injectors.html#xdi.injectors","text":"","title":"injectors"},{"location":"api/injectors.html#xdi.injectors.Injector","text":"Bases: FrozenDict [ T_Injectable , Callable [[], T_Injected ]] An isolated dependency injection context for a given Scope . Attributes: Name Type Description scope Scope the scope for this injector parent Injector a parent injector to provide missing dependencies. Parameters: Name Type Description Default scope Scope the scope for this injector required parent Injector a parent injector to provide missing dependencies. None","title":"Injector"},{"location":"api/injectors.html#xdi.injectors.Injector.name","text":"The name of the scope. Usually returns the injector's scope.name","title":"name()"},{"location":"api/injectors.html#xdi.injectors.NullInjector","text":"Bases: Injector A 'noop' Injector used as the parent of root injectors. Attributes: Name Type Description scope NullScope the scope parent None The parent injector","title":"NullInjector"},{"location":"api/injectors.html#xdi.injectors._InjectorExitStack","text":"Bases: list [ tuple [ bool , _T_Fn ]] Async context manager for dynamic management of a stack of exit callbacks. For example async with AsyncExitStack() as stack: connections = [await stack.enter_async_context(get_connection()) for i in range(5)] # All opened connections will automatically be released at the # end of the async with statement, even if attempts to open a # connection later in the list raise an exception.","title":"_InjectorExitStack"},{"location":"api/injectors.html#xdi.injectors._InjectorExitStack.push","text":"Registers a callback with the standard exit method signature. Can suppress exceptions the same way exit method can. Also accepts any object with an exit method (registering a call to the method instead of the object itself).","title":"push()"},{"location":"api/injectors.html#xdi.injectors._InjectorExitStack.enter","text":"Enters the supplied context manager. If successful, also pushes its exit method as a callback and returns the result of the enter method.","title":"enter()"},{"location":"api/injectors.html#xdi.injectors._InjectorExitStack.callback","text":"Registers an arbitrary callback and arguments. Cannot suppress exceptions.","title":"callback()"},{"location":"api/injectors.html#xdi.injectors._InjectorExitStack.close","text":"Immediately unwind the context stack.","title":"close()"},{"location":"api/injectors.html#xdi.injectors._InjectorExitStack.enter_async","text":"Enters the supplied async context manager. If successful, also pushes its aexit method as a callback and returns the result of the aenter method.","title":"enter_async()"},{"location":"api/injectors.html#xdi.injectors._InjectorExitStack.push_async_exit","text":"Registers a coroutine function with the standard aexit method signature. Can suppress exceptions the same way aexit method can. Also accepts any object with an aexit method (registering a call to the method instead of the object itself).","title":"push_async_exit()"},{"location":"api/injectors.html#xdi.injectors._InjectorExitStack.callback_async","text":"Registers an arbitrary coroutine function and arguments. Cannot suppress exceptions.","title":"callback_async()"},{"location":"api/injectors.html#xdi.injectors._InjectorExitStack.aclose","text":"Immediately unwind the context stack.","title":"aclose()"},{"location":"api/injectors.html#xdi.injectors._InjectorExitStack._push_async_cm_exit","text":"Helper to correctly register coroutine function to aexit method.","title":"_push_async_cm_exit()"},{"location":"api/markers.html","text":"Markers \u00b6 xdi.markers \u00b6 DependencyMarker \u00b6 Bases: Injectable , t . Generic [ T_Injectable ] Abstract base class for dependency markers. Dependency markers are used reperesent and/or annotate dependencies. DepScope \u00b6 Bases: IntEnum any : 'DepScope' = 0 class-attribute \u00b6 Inject from any scope. only_self : 'DepScope' = 1 class-attribute \u00b6 Only inject from the current scope without considering parents skip_self : 'DepScope' = 2 class-attribute \u00b6 Skip the current scope and resolve from it's parent instead. PureDep \u00b6 Bases: DependencyMarker , t . Generic [ T_Injectable ] Explicitly marks given injectable as a dependency. Attributes: Name Type Description abstract T_Injectable the marked dependency. Parameters: Name Type Description Default abstract T_Injectable the dependency to mark. required Dep \u00b6 Bases: DependencyMarker , _AbcDepTuple Marks an injectable as a dependency to be injected. ANY_SCOPE : t . Final = DepScope . any class-attribute \u00b6 Inject from any scope. ONLY_SELF : t . Final = DepScope . only_self class-attribute \u00b6 Only inject from the current scope without considering parents SKIP_SELF : t . Final = DepScope . skip_self class-attribute \u00b6 Skip the current scope and resolve from it's parent instead. Lookup \u00b6 Bases: DependencyMarker , BaseLookup Represents a lazy lookup of a given dependency. Attributes: Name Type Description __abstract__ Injectable the dependency to lookup. Parameters: Name Type Description Default abstract Injectable the dependency to lookup. required","title":"xdi.markers"},{"location":"api/markers.html#markers","text":"","title":"Markers"},{"location":"api/markers.html#xdi.markers","text":"","title":"markers"},{"location":"api/markers.html#xdi.markers.DependencyMarker","text":"Bases: Injectable , t . Generic [ T_Injectable ] Abstract base class for dependency markers. Dependency markers are used reperesent and/or annotate dependencies.","title":"DependencyMarker"},{"location":"api/markers.html#xdi.markers.DepScope","text":"Bases: IntEnum","title":"DepScope"},{"location":"api/markers.html#xdi.markers.DepScope.any","text":"Inject from any scope.","title":"any"},{"location":"api/markers.html#xdi.markers.DepScope.only_self","text":"Only inject from the current scope without considering parents","title":"only_self"},{"location":"api/markers.html#xdi.markers.DepScope.skip_self","text":"Skip the current scope and resolve from it's parent instead.","title":"skip_self"},{"location":"api/markers.html#xdi.markers.PureDep","text":"Bases: DependencyMarker , t . Generic [ T_Injectable ] Explicitly marks given injectable as a dependency. Attributes: Name Type Description abstract T_Injectable the marked dependency. Parameters: Name Type Description Default abstract T_Injectable the dependency to mark. required","title":"PureDep"},{"location":"api/markers.html#xdi.markers.Dep","text":"Bases: DependencyMarker , _AbcDepTuple Marks an injectable as a dependency to be injected.","title":"Dep"},{"location":"api/markers.html#xdi.markers.Dep.ANY_SCOPE","text":"Inject from any scope.","title":"ANY_SCOPE"},{"location":"api/markers.html#xdi.markers.Dep.ONLY_SELF","text":"Only inject from the current scope without considering parents","title":"ONLY_SELF"},{"location":"api/markers.html#xdi.markers.Dep.SKIP_SELF","text":"Skip the current scope and resolve from it's parent instead.","title":"SKIP_SELF"},{"location":"api/markers.html#xdi.markers.Lookup","text":"Bases: DependencyMarker , BaseLookup Represents a lazy lookup of a given dependency. Attributes: Name Type Description __abstract__ Injectable the dependency to lookup. Parameters: Name Type Description Default abstract Injectable the dependency to lookup. required","title":"Lookup"},{"location":"api/scopes.html","text":"Scopes \u00b6 xdi.scopes \u00b6 Scope \u00b6 Bases: FrozenDict [ tuple , t . Union [ Binding , None]] An isolated dependency resolution scope for a given container. Scopes assemble the dependency graphs of dependencies registered in their container. Attributes: Name Type Description container Container The container who's scope we are creating parent Scope The parent scope. Defaults to None Parameters: Name Type Description Default container Container The container who's scope we are creating required parent Scope The parent scope. Defaults to NullScope required name () -> str property \u00b6 The name of the scope. Usually returns the scope's container.name parents () \u00b6 Returns a generetor that iterates over the scope's ancestor starting from the current parent to the root scope. Yields: Name Type Description ancestor Scope an ancestor. NullScope \u00b6 Bases: Scope A 'noop' Scope used as the parent of root scopes. Attributes: Name Type Description container frozendict parent None The parent scope","title":"xdi.scopes"},{"location":"api/scopes.html#scopes","text":"","title":"Scopes"},{"location":"api/scopes.html#xdi.scopes","text":"","title":"scopes"},{"location":"api/scopes.html#xdi.scopes.Scope","text":"Bases: FrozenDict [ tuple , t . Union [ Binding , None]] An isolated dependency resolution scope for a given container. Scopes assemble the dependency graphs of dependencies registered in their container. Attributes: Name Type Description container Container The container who's scope we are creating parent Scope The parent scope. Defaults to None Parameters: Name Type Description Default container Container The container who's scope we are creating required parent Scope The parent scope. Defaults to NullScope required","title":"Scope"},{"location":"api/scopes.html#xdi.scopes.Scope.name","text":"The name of the scope. Usually returns the scope's container.name","title":"name()"},{"location":"api/scopes.html#xdi.scopes.Scope.parents","text":"Returns a generetor that iterates over the scope's ancestor starting from the current parent to the root scope. Yields: Name Type Description ancestor Scope an ancestor.","title":"parents()"},{"location":"api/scopes.html#xdi.scopes.NullScope","text":"Bases: Scope A 'noop' Scope used as the parent of root scopes. Attributes: Name Type Description container frozendict parent None The parent scope","title":"NullScope"},{"location":"api/providers/alias.html","text":"Alias \u00b6 xdi.providers.Alias \u00b6 Bases: Provider [ T_Injectable , bindings . _T_Binding ] Used to proxy another existing dependency. It resolves to the given concrete . For example. To use _Ta for dependency _Tb . container[_Tb] = Alias(_Ta) Parameters: Name Type Description Default concrete Injectable The dependency to be proxied required","title":"Alias"},{"location":"api/providers/alias.html#alias","text":"","title":"Alias"},{"location":"api/providers/alias.html#xdi.providers.Alias","text":"Bases: Provider [ T_Injectable , bindings . _T_Binding ] Used to proxy another existing dependency. It resolves to the given concrete . For example. To use _Ta for dependency _Tb . container[_Tb] = Alias(_Ta) Parameters: Name Type Description Default concrete Injectable The dependency to be proxied required","title":"Alias"},{"location":"api/providers/annotation.html","text":"AnnotationProvider \u00b6 xdi.providers.AnnotationProvider \u00b6 Bases: UnionProvider [ _T_Concrete ] Annotated types provider","title":"AnnotationProvider"},{"location":"api/providers/annotation.html#annotationprovider","text":"","title":"AnnotationProvider"},{"location":"api/providers/annotation.html#xdi.providers.AnnotationProvider","text":"Bases: UnionProvider [ _T_Concrete ] Annotated types provider","title":"AnnotationProvider"},{"location":"api/providers/callable.html","text":"Callable \u00b6 xdi.providers.Callable \u00b6 Bases: Partial [ T_Injected , bindings . _T_CallableBinding ] Similar to a Factory provider, a Callable provider resolves to a callable that wraps the factory.","title":"Callable"},{"location":"api/providers/callable.html#callable","text":"","title":"Callable"},{"location":"api/providers/callable.html#xdi.providers.Callable","text":"Bases: Partial [ T_Injected , bindings . _T_CallableBinding ] Similar to a Factory provider, a Callable provider resolves to a callable that wraps the factory.","title":"Callable"},{"location":"api/providers/dep.html","text":"DepMarkerProvider \u00b6 xdi.providers.DepMarkerProvider \u00b6 Bases: Provider [ _T_Concrete ] Provider for resolving zdi.Dep dependencies.","title":"DepMarkerProvider"},{"location":"api/providers/dep.html#depmarkerprovider","text":"","title":"DepMarkerProvider"},{"location":"api/providers/dep.html#xdi.providers.DepMarkerProvider","text":"Bases: Provider [ _T_Concrete ] Provider for resolving zdi.Dep dependencies.","title":"DepMarkerProvider"},{"location":"api/providers/factory.html","text":"Factory \u00b6 xdi.providers.Factory \u00b6 Bases: Provider [ abc . Callable [..., T_Injected ], bindings . _T_FactoryBinding ] , t . Generic [ T_Injected , bindings . _T_FactoryBinding ] Resolves to the return value of the given factory. A factory can be a type , function or a Callable object. The factory is called every time a dependency for this provider is requested. Attributes: Name Type Description concrete Union [ type [ T_Injected ], abc . Callable [..., T_Injected ]] the factory to used to create the provided value. arguments tuple [ tuple . frozendict ] A tuple of positional and keyword arguments passed to the factory. Parameters: Name Type Description Default concrete Union [ type [ T_Injected ], abc . Callable [..., T_Injected ]] the factory. Can be a type , function or a Callable object. None *args Union [ Dep , Any ] Positional arguments to pass to the factory. () **kwargs Union [ Dep , Any ] Keyword arguments to pass to the factory. {} With Arguments \u00b6 Positional and/or keyword arguments to pass to the factory may be provided. Values Only \u00b6 1 2 Factory ( func , 'a' , 32 , obj , key = 'xyz' ) # will call: func('a', 32, obj, key='xyz') Values and Dependencies \u00b6 Arguments of type DependencyMarker will automatically be resolved and passed to the factory while calling it. e.g. using Dep and Lookup : 1 2 3 4 5 6 7 8 9 Factory ( func , 'a' , xdi . makers . Dep ( Foo ), obj , key = 'xyz' , bar = xdi . makers . Lookup ( FooBar ) . bar ) # will call: func('a', <inject: Foo>, obj, key='xyz', bar=<inject: FooBar>.bar) asynchronous ( is_async : bool = True ) -> Self \u00b6 Mark/Unmark this provider as asynchronous. Updates is_async attribute. Normally, coroutines and factories with async dependencies automatically detected as asynchronous. This method provides the ability to change this default behaviour. Parameters: Name Type Description Default is_async Union [ bool , None] True to mark , False to unmark or None to revert to the default behaviour. Defaults to True . True Returns: Name Type Description self Provider this provider args ( * args ) -> Self \u00b6 Set the positional arguments to pass to the factory. Updates the arguments attribute. Parameters: Name Type Description Default *args Union [ Dep , Any ] Positional arguments to pass to the factory. () Returns: Name Type Description self Provider this provider kwargs ( ** kwargs ) -> Self \u00b6 Set the keyword arguments to pass to the factory. Updates the arguments attribute. Parameters: Name Type Description Default **kwargs Union [ Dep , Any ] Keyword arguments to pass to the factory. {} Returns: Name Type Description self Provider this provider use ( concrete , * args , ** kwargs ) \u00b6 Sets the provider's factory and arguments. Parameters: Name Type Description Default concrete Union [ type [ T_Injected ], abc . Callable [..., T_Injected ]] the factory. Can be a type , function or a Callable object. required *args Union [ Dep , Any ] Positional arguments to pass to the factory. () **kwargs Union [ Dep , Any ] Keyword arguments to pass to the factory. {} Returns: Name Type Description self Factory this provider signature ( signature : Signature ) -> Self \u00b6 Set a custom Signature for the factory. Parameters: Name Type Description Default signature Signature the signature required Returns: Name Type Description self Factory this provider","title":"Factory"},{"location":"api/providers/factory.html#factory","text":"","title":"Factory"},{"location":"api/providers/factory.html#xdi.providers.Factory","text":"Bases: Provider [ abc . Callable [..., T_Injected ], bindings . _T_FactoryBinding ] , t . Generic [ T_Injected , bindings . _T_FactoryBinding ] Resolves to the return value of the given factory. A factory can be a type , function or a Callable object. The factory is called every time a dependency for this provider is requested. Attributes: Name Type Description concrete Union [ type [ T_Injected ], abc . Callable [..., T_Injected ]] the factory to used to create the provided value. arguments tuple [ tuple . frozendict ] A tuple of positional and keyword arguments passed to the factory. Parameters: Name Type Description Default concrete Union [ type [ T_Injected ], abc . Callable [..., T_Injected ]] the factory. Can be a type , function or a Callable object. None *args Union [ Dep , Any ] Positional arguments to pass to the factory. () **kwargs Union [ Dep , Any ] Keyword arguments to pass to the factory. {}","title":"Factory"},{"location":"api/providers/factory.html#xdi.providers.Factory--with-arguments","text":"Positional and/or keyword arguments to pass to the factory may be provided.","title":"With Arguments"},{"location":"api/providers/factory.html#xdi.providers.Factory--values-only","text":"1 2 Factory ( func , 'a' , 32 , obj , key = 'xyz' ) # will call: func('a', 32, obj, key='xyz')","title":"Values Only"},{"location":"api/providers/factory.html#xdi.providers.Factory--values-and-dependencies","text":"Arguments of type DependencyMarker will automatically be resolved and passed to the factory while calling it. e.g. using Dep and Lookup : 1 2 3 4 5 6 7 8 9 Factory ( func , 'a' , xdi . makers . Dep ( Foo ), obj , key = 'xyz' , bar = xdi . makers . Lookup ( FooBar ) . bar ) # will call: func('a', <inject: Foo>, obj, key='xyz', bar=<inject: FooBar>.bar)","title":"Values and Dependencies"},{"location":"api/providers/factory.html#xdi.providers.Factory.asynchronous","text":"Mark/Unmark this provider as asynchronous. Updates is_async attribute. Normally, coroutines and factories with async dependencies automatically detected as asynchronous. This method provides the ability to change this default behaviour. Parameters: Name Type Description Default is_async Union [ bool , None] True to mark , False to unmark or None to revert to the default behaviour. Defaults to True . True Returns: Name Type Description self Provider this provider","title":"asynchronous()"},{"location":"api/providers/factory.html#xdi.providers.Factory.args","text":"Set the positional arguments to pass to the factory. Updates the arguments attribute. Parameters: Name Type Description Default *args Union [ Dep , Any ] Positional arguments to pass to the factory. () Returns: Name Type Description self Provider this provider","title":"args()"},{"location":"api/providers/factory.html#xdi.providers.Factory.kwargs","text":"Set the keyword arguments to pass to the factory. Updates the arguments attribute. Parameters: Name Type Description Default **kwargs Union [ Dep , Any ] Keyword arguments to pass to the factory. {} Returns: Name Type Description self Provider this provider","title":"kwargs()"},{"location":"api/providers/factory.html#xdi.providers.Factory.use","text":"Sets the provider's factory and arguments. Parameters: Name Type Description Default concrete Union [ type [ T_Injected ], abc . Callable [..., T_Injected ]] the factory. Can be a type , function or a Callable object. required *args Union [ Dep , Any ] Positional arguments to pass to the factory. () **kwargs Union [ Dep , Any ] Keyword arguments to pass to the factory. {} Returns: Name Type Description self Factory this provider","title":"use()"},{"location":"api/providers/factory.html#xdi.providers.Factory.signature","text":"Set a custom Signature for the factory. Parameters: Name Type Description Default signature Signature the signature required Returns: Name Type Description self Factory this provider","title":"signature()"},{"location":"api/providers/lookup.html","text":"LookupMarkerProvider \u00b6 xdi.providers.LookupMarkerProvider \u00b6 Bases: Factory [ lookups . look , bindings . _T_FactoryBinding ] Provider for resolving xdi.Lookup dependencies.","title":"LookupMarkerProvider"},{"location":"api/providers/lookup.html#lookupmarkerprovider","text":"","title":"LookupMarkerProvider"},{"location":"api/providers/lookup.html#xdi.providers.LookupMarkerProvider","text":"Bases: Factory [ lookups . look , bindings . _T_FactoryBinding ] Provider for resolving xdi.Lookup dependencies.","title":"LookupMarkerProvider"},{"location":"api/providers/partial.html","text":"Partial \u00b6 xdi.providers.Partial \u00b6 Bases: Factory [ T_Injected , bindings . _T_PartialBinding ] A Factory provider that accepts extra arguments during resolution. Used internally to inject entry-point functions.","title":"Partial"},{"location":"api/providers/partial.html#partial","text":"","title":"Partial"},{"location":"api/providers/partial.html#xdi.providers.Partial","text":"Bases: Factory [ T_Injected , bindings . _T_PartialBinding ] A Factory provider that accepts extra arguments during resolution. Used internally to inject entry-point functions.","title":"Partial"},{"location":"api/providers/provider.html","text":"Provider \u00b6 xdi.providers.Provider \u00b6 Bases: t . Generic [ _T_Concrete , _T_Binding ] The base class for all providers. Subclasses can implement the _resolve() method to return the appropriate Dependency object for any given dependency. Also, conditional providers can implement the _can_resolve()' method which should return True when the provider can resolve or False` if otherwise. Attributes: Name Type Description concrete Any The object used to resolve container Container The Container where this provider is defined. is_default bool Whether this provider is the default. A default provider only gets used if none other was provided to override it. is_async bool Whether this provider is asyncnous filters tuple [ Callable ] Called to determine whether this provider can be resolved. default ( is_default : bool = True ) -> Self \u00b6 Mark/Unmark this provider as the default. Updates the provider's is_default attribute. A default provider will be skipped if the dependency they provide has another provider. This means that a default provider will only get used if no other providers for the given dependency were defined in the current scope. Parameters: Name Type Description Default is_default bool True to mark or False to unmark . Defaults to True . True Returns: Name Type Description self Provider this provider can_resolve ( abstract : T_Injectable , scope : 'Scope' ) -> bool \u00b6 Check if this provider can resolve the given dependency in the given scope. Used internally by the resolve method. Runs the provider's filters and if any of them fails (returns False ), this method will return False . Parameters: Name Type Description Default abstract T_Injectable dependency to be resolved required scope Scope Scope within which the dependency is getting resolved. required Returns: Name Type Description bool bool True if dependency can be resolved or False if otherwise. resolve ( abstract : T_Injectable , scope : 'Scope' ) -> _T_Binding \u00b6 Resolve the given dependency. Used internally by Scope Parameters: Name Type Description Default abstract T_Injectable dependency to be resolved required scope Scope Scope within which the dependency is getting resolved. required Returns: Name Type Description dependency Optional [ Dependency ] set_container ( container : 'Container' ) -> Self \u00b6 Sets the provide's container Parameters: Name Type Description Default container Container description required Raises: Type Description AttributeError When another container was already set Returns: Name Type Description self Provider this provider use ( using : _T_Concrete ) -> Self \u00b6 Set the provider's concrete attribute. The given value will depend on the type of provider Can be used as decorator @provider.use() def func(): ... Parameters: Name Type Description Default using _T_Concrete the object to provide. this depends on the type of provider required Returns: Name Type Description self Provider this provider when ( * filters : abc . Callable , replace : bool = False ) -> Self \u00b6 Add/replace the provider's filters . Filters are callables that determine whether this provider can provide a given dependency. Filters are called with 3 arguments. Namely: provider - this provide, abstract - the dependency to be provided and scope - scope within which the dependency is getting resolved. Parameters: Name Type Description Default *filters Callable The filter callables. () replace bool Whether to replace the existing filters instead of adding. Defaults to False. False Returns: Name Type Description self Provider this provider","title":"Provider"},{"location":"api/providers/provider.html#provider","text":"","title":"Provider"},{"location":"api/providers/provider.html#xdi.providers.Provider","text":"Bases: t . Generic [ _T_Concrete , _T_Binding ] The base class for all providers. Subclasses can implement the _resolve() method to return the appropriate Dependency object for any given dependency. Also, conditional providers can implement the _can_resolve()' method which should return True when the provider can resolve or False` if otherwise. Attributes: Name Type Description concrete Any The object used to resolve container Container The Container where this provider is defined. is_default bool Whether this provider is the default. A default provider only gets used if none other was provided to override it. is_async bool Whether this provider is asyncnous filters tuple [ Callable ] Called to determine whether this provider can be resolved.","title":"Provider"},{"location":"api/providers/provider.html#xdi.providers.Provider.default","text":"Mark/Unmark this provider as the default. Updates the provider's is_default attribute. A default provider will be skipped if the dependency they provide has another provider. This means that a default provider will only get used if no other providers for the given dependency were defined in the current scope. Parameters: Name Type Description Default is_default bool True to mark or False to unmark . Defaults to True . True Returns: Name Type Description self Provider this provider","title":"default()"},{"location":"api/providers/provider.html#xdi.providers.Provider.can_resolve","text":"Check if this provider can resolve the given dependency in the given scope. Used internally by the resolve method. Runs the provider's filters and if any of them fails (returns False ), this method will return False . Parameters: Name Type Description Default abstract T_Injectable dependency to be resolved required scope Scope Scope within which the dependency is getting resolved. required Returns: Name Type Description bool bool True if dependency can be resolved or False if otherwise.","title":"can_resolve()"},{"location":"api/providers/provider.html#xdi.providers.Provider.resolve","text":"Resolve the given dependency. Used internally by Scope Parameters: Name Type Description Default abstract T_Injectable dependency to be resolved required scope Scope Scope within which the dependency is getting resolved. required Returns: Name Type Description dependency Optional [ Dependency ]","title":"resolve()"},{"location":"api/providers/provider.html#xdi.providers.Provider.set_container","text":"Sets the provide's container Parameters: Name Type Description Default container Container description required Raises: Type Description AttributeError When another container was already set Returns: Name Type Description self Provider this provider","title":"set_container()"},{"location":"api/providers/provider.html#xdi.providers.Provider.use","text":"Set the provider's concrete attribute. The given value will depend on the type of provider Can be used as decorator @provider.use() def func(): ... Parameters: Name Type Description Default using _T_Concrete the object to provide. this depends on the type of provider required Returns: Name Type Description self Provider this provider","title":"use()"},{"location":"api/providers/provider.html#xdi.providers.Provider.when","text":"Add/replace the provider's filters . Filters are callables that determine whether this provider can provide a given dependency. Filters are called with 3 arguments. Namely: provider - this provide, abstract - the dependency to be provided and scope - scope within which the dependency is getting resolved. Parameters: Name Type Description Default *filters Callable The filter callables. () replace bool Whether to replace the existing filters instead of adding. Defaults to False. False Returns: Name Type Description self Provider this provider","title":"when()"},{"location":"api/providers/registry.html","text":"AbstractProviderRegistry \u00b6 xdi.providers.AbstractProviderRegistry \u00b6 Bases: ABC Implements a collection of helper methods for creating providers. Subclassed by Container to provide these methods","title":"AbstractProviderRegistry"},{"location":"api/providers/registry.html#abstractproviderregistry","text":"","title":"AbstractProviderRegistry"},{"location":"api/providers/registry.html#xdi.providers.AbstractProviderRegistry","text":"Bases: ABC Implements a collection of helper methods for creating providers. Subclassed by Container to provide these methods","title":"AbstractProviderRegistry"},{"location":"api/providers/resource.html","text":"Resource \u00b6 xdi.providers.Resource \u00b6 Bases: Singleton [ T_Injected , bindings . _T_ResourceBinding ] A Resource provider is a Singleton that has initialization and/or teardown.","title":"Resource"},{"location":"api/providers/resource.html#resource","text":"","title":"Resource"},{"location":"api/providers/resource.html#xdi.providers.Resource","text":"Bases: Singleton [ T_Injected , bindings . _T_ResourceBinding ] A Resource provider is a Singleton that has initialization and/or teardown.","title":"Resource"},{"location":"api/providers/singleton.html","text":"Singleton \u00b6 xdi.providers.Singleton \u00b6 Bases: Factory [ T_Injected , bindings . _T_SingletonBinding ] A Singleton provider is a Factory that returns same instance on every call. On the first request, the given factory will be called to create the instance which will be stored and returned on subsequent requests. Attributes: Name Type Description is_thread_safe bool Indicates whether to wrap the factory call with a Lock to prevent simultaneous instance create when injecting from multiple threads. Defaults to None thread_safe ( is_thread_safe : bool = True ) -> Self \u00b6 Mark/Unmark this provider as thread safe. Updates the is_thread_safe attribute. is_thread_safe indicates whether to wrap the factory call with a Lock to prevent simultaneous instance create when injecting from multiple threads. Parameters: Name Type Description Default is_thread_safe bool True to mark or False to unmark . Defaults to True. True Returns: Name Type Description self Provider this provider","title":"Singleton"},{"location":"api/providers/singleton.html#singleton","text":"","title":"Singleton"},{"location":"api/providers/singleton.html#xdi.providers.Singleton","text":"Bases: Factory [ T_Injected , bindings . _T_SingletonBinding ] A Singleton provider is a Factory that returns same instance on every call. On the first request, the given factory will be called to create the instance which will be stored and returned on subsequent requests. Attributes: Name Type Description is_thread_safe bool Indicates whether to wrap the factory call with a Lock to prevent simultaneous instance create when injecting from multiple threads. Defaults to None","title":"Singleton"},{"location":"api/providers/singleton.html#xdi.providers.Singleton.thread_safe","text":"Mark/Unmark this provider as thread safe. Updates the is_thread_safe attribute. is_thread_safe indicates whether to wrap the factory call with a Lock to prevent simultaneous instance create when injecting from multiple threads. Parameters: Name Type Description Default is_thread_safe bool True to mark or False to unmark . Defaults to True. True Returns: Name Type Description self Provider this provider","title":"thread_safe()"},{"location":"api/providers/union.html","text":"UnionProvider \u00b6 xdi.providers.UnionProvider \u00b6 Bases: Provider [ _T_Concrete ] Provider for resolving Union dependencies.","title":"UnionProvider"},{"location":"api/providers/union.html#unionprovider","text":"","title":"UnionProvider"},{"location":"api/providers/union.html#xdi.providers.UnionProvider","text":"Bases: Provider [ _T_Concrete ] Provider for resolving Union dependencies.","title":"UnionProvider"},{"location":"api/providers/value.html","text":"Value \u00b6 xdi.providers.Value \u00b6 Bases: Provider [ T_Injected , bindings . _T_ValueBinding ] Provides the given object as it is. Example T will always resolve to obj . obj = object() container[T] = Value(obj) Parameters: Name Type Description Default concrete T_Injected The object to be provided required","title":"Value"},{"location":"api/providers/value.html#value","text":"","title":"Value"},{"location":"api/providers/value.html#xdi.providers.Value","text":"Bases: Provider [ T_Injected , bindings . _T_ValueBinding ] Provides the given object as it is. Example T will always resolve to obj . obj = object() container[T] = Value(obj) Parameters: Name Type Description Default concrete T_Injected The object to be provided required","title":"Value"},{"location":"basic/index.html","text":"Getting Started \u00b6 This is an introductory tutorial on how to use xdi . Here we'll look at some simple examples on how you can use xdi whilst introducing you to some it's cool features. After this, you will be able to start using xdi in your projects.","title":"Getting Started"},{"location":"basic/index.html#getting-started","text":"This is an introductory tutorial on how to use xdi . Here we'll look at some simple examples on how you can use xdi whilst introducing you to some it's cool features. After this, you will be able to start using xdi in your projects.","title":"Getting Started"},{"location":"basic/providers/index.html","text":"Providers \u00b6 Introduction \u00b6 Providers are xdi 's main building block. We use them to define how objects will created and assembled. Available Providers \u00b6 xdi comes with a number of providers to most common use cases. Value Provider Factory Provider Singleton Provider Resource Provider Callable Provider Alias Provider Implicit Providers Annotated Types Union Types Dep Marker","title":"Providers"},{"location":"basic/providers/index.html#providers","text":"","title":"Providers"},{"location":"basic/providers/index.html#introduction","text":"Providers are xdi 's main building block. We use them to define how objects will created and assembled.","title":"Introduction"},{"location":"basic/providers/index.html#available-providers","text":"xdi comes with a number of providers to most common use cases. Value Provider Factory Provider Singleton Provider Resource Provider Callable Provider Alias Provider Implicit Providers Annotated Types Union Types Dep Marker","title":"Available Providers"},{"location":"basic/providers/alias.html","text":"Alias Provider \u00b6 Used to \"alias\" another existing dependency. Simple Usage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import typing as t import xdi _Ta = t . TypeVar ( '_Ta' ) _Tb = t . TypeVar ( '_Tb' ) container = xdi . Container () # a) using the helper method container . alias ( _Tb , _Ta ) # or # b) manually creating and attaching the provider container [ _Ta ] = xdi . providers . Alias ( _Ta ) obj = object () # bind `_Ta` to a constant `obj` container . value ( _Ta , obj ) if __name__ == '__main__' : injector = xdi . Injector ( xdi . Scope ( container )) assert obj is injector . make ( _Ta ) is injector . make ( _Tb ) In the above snippet, dependents of both _Tb and _Ta will be provided with obj . Use Case \u00b6 import typing as t from xdi import Container , providers _Ta = t . TypeVar ( '_Ta' ) _Tb = t . TypeVar ( '_Tb' ) class Cache : ... class DbCache ( Cache ): ... class MemoryCache ( Cache ): ... class RedisCache ( Cache ): ... container = Container () container . singleton ( DbCache ) container . singleton ( RedisCache ) container . singleton ( MemoryCache ) container . alias ( Cache , RedisCache )","title":"Alias Provider"},{"location":"basic/providers/alias.html#alias-provider","text":"Used to \"alias\" another existing dependency. Simple Usage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import typing as t import xdi _Ta = t . TypeVar ( '_Ta' ) _Tb = t . TypeVar ( '_Tb' ) container = xdi . Container () # a) using the helper method container . alias ( _Tb , _Ta ) # or # b) manually creating and attaching the provider container [ _Ta ] = xdi . providers . Alias ( _Ta ) obj = object () # bind `_Ta` to a constant `obj` container . value ( _Ta , obj ) if __name__ == '__main__' : injector = xdi . Injector ( xdi . Scope ( container )) assert obj is injector . make ( _Ta ) is injector . make ( _Tb ) In the above snippet, dependents of both _Tb and _Ta will be provided with obj .","title":"Alias Provider"},{"location":"basic/providers/alias.html#use-case","text":"import typing as t from xdi import Container , providers _Ta = t . TypeVar ( '_Ta' ) _Tb = t . TypeVar ( '_Tb' ) class Cache : ... class DbCache ( Cache ): ... class MemoryCache ( Cache ): ... class RedisCache ( Cache ): ... container = Container () container . singleton ( DbCache ) container . singleton ( RedisCache ) container . singleton ( MemoryCache ) container . alias ( Cache , RedisCache )","title":"Use Case"},{"location":"basic/providers/callable.html","text":"Callable Provider \u00b6 Provides a partial callable to a function, class, method or any other callable type 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import typing as t from xdi import Container , providers _T_PasswordHasher = t . TypeVar ( \"_T_PasswordHasher\" , bound = t . Callable [[ str ], str ]) def hash_password ( password : str , salt : str , rounds : int = 5000 , algo : t . Literal [ \"sha256\" , \"sha512\" , \"md5\" ] = \"md5\" , ): return \"hashed_password\" container = Container () container [ _T_PasswordHasher ] = providers . Callable ( hash_password , salt = \"my-secret\" , rounds = 1000 , algo = \"sha256\" ) # or use the helper method container . callable ( _T_PasswordHasher , hash_password , salt = \"my-secret\" , rounds = 1000 , algo = \"sha256\" )","title":"Callable Provider"},{"location":"basic/providers/callable.html#callable-provider","text":"Provides a partial callable to a function, class, method or any other callable type 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import typing as t from xdi import Container , providers _T_PasswordHasher = t . TypeVar ( \"_T_PasswordHasher\" , bound = t . Callable [[ str ], str ]) def hash_password ( password : str , salt : str , rounds : int = 5000 , algo : t . Literal [ \"sha256\" , \"sha512\" , \"md5\" ] = \"md5\" , ): return \"hashed_password\" container = Container () container [ _T_PasswordHasher ] = providers . Callable ( hash_password , salt = \"my-secret\" , rounds = 1000 , algo = \"sha256\" ) # or use the helper method container . callable ( _T_PasswordHasher , hash_password , salt = \"my-secret\" , rounds = 1000 , algo = \"sha256\" )","title":"Callable Provider"},{"location":"basic/providers/custom.html","text":"Create Custom Provider \u00b6 Available providers don't suite your needs? You can create a custom one.","title":"Create Custom Provider"},{"location":"basic/providers/custom.html#create-custom-provider","text":"Available providers don't suite your needs? You can create a custom one.","title":"Create Custom Provider"},{"location":"basic/providers/factory.html","text":"Factory Provider \u00b6 The Factory provider creates new objects every time it's requested. 1 2 3 4 5 6 7 8 9 10 from xdi import Container , providers class Service : ... container = Container () container . factory ( Service ) # or manually create the provider container [ Service ] = providers . Factory ( Service )","title":"Factory Provider"},{"location":"basic/providers/factory.html#factory-provider","text":"The Factory provider creates new objects every time it's requested. 1 2 3 4 5 6 7 8 9 10 from xdi import Container , providers class Service : ... container = Container () container . factory ( Service ) # or manually create the provider container [ Service ] = providers . Factory ( Service )","title":"Factory Provider"},{"location":"basic/providers/implicit.html","text":"Implicit Providers \u00b6 Annotated Types \u00b6 Support for typing.Annotated . . . Union Types \u00b6 Support for typing.Union . . . Dep Maker \u00b6 Support for xdi.Dep . . . x","title":"Implicit Providers"},{"location":"basic/providers/implicit.html#implicit-providers","text":"","title":"Implicit Providers"},{"location":"basic/providers/implicit.html#annotated-types","text":"Support for typing.Annotated . . .","title":"Annotated Types"},{"location":"basic/providers/implicit.html#union-types","text":"Support for typing.Union . . .","title":"Union Types"},{"location":"basic/providers/implicit.html#dep-maker","text":"Support for xdi.Dep . . . x","title":"Dep Maker"},{"location":"basic/providers/resource.html","text":"Resource Provider \u00b6 For services that have initialization and/or teardown stage(s).","title":"Resource Provider"},{"location":"basic/providers/resource.html#resource-provider","text":"For services that have initialization and/or teardown stage(s).","title":"Resource Provider"},{"location":"basic/providers/singleton.html","text":"Singleton Provider \u00b6 The Singleton provider creates and provides single object. It memorizes the first created object and returns it on the rest of the calls. 1 2 3 4 5 6 7 8 9 10 from xdi import Container , providers class Service : ... container = Container () container . singleton ( Service ) # or manually create the provider container [ Service ] = providers . Singleton ( Service )","title":"Singleton Provider"},{"location":"basic/providers/singleton.html#singleton-provider","text":"The Singleton provider creates and provides single object. It memorizes the first created object and returns it on the rest of the calls. 1 2 3 4 5 6 7 8 9 10 from xdi import Container , providers class Service : ... container = Container () container . singleton ( Service ) # or manually create the provider container [ Service ] = providers . Singleton ( Service )","title":"Singleton Provider"},{"location":"basic/providers/value.html","text":"Value Provider \u00b6 Provide given an object \"as is\". Simple Usage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from types import SimpleNamespace import xdi class Config ( SimpleNamespace ): debug : bool = False database : str config = Config ( debug = True , database = ':memory:' ) container = xdi . Container () # a) using the helper method container . value ( Config , config ) # or # b) manually creating and attaching the provider container [ Config ] = xdi . providers . Value ( config ) if __name__ == '__main__' : injector = xdi . Injector ( xdi . Scope ( container )) assert config == injector . make ( Config ) assert config is injector . make ( Config )","title":"Value Provider"},{"location":"basic/providers/value.html#value-provider","text":"Provide given an object \"as is\". Simple Usage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from types import SimpleNamespace import xdi class Config ( SimpleNamespace ): debug : bool = False database : str config = Config ( debug = True , database = ':memory:' ) container = xdi . Container () # a) using the helper method container . value ( Config , config ) # or # b) manually creating and attaching the provider container [ Config ] = xdi . providers . Value ( config ) if __name__ == '__main__' : injector = xdi . Injector ( xdi . Scope ( container )) assert config == injector . make ( Config ) assert config is injector . make ( Config )","title":"Value Provider"},{"location":"examples/index.html","text":"Examples \u00b6","title":"Examples"},{"location":"examples/index.html#examples","text":"","title":"Examples"},{"location":"frameworks/index.html","text":"Framework Integration \u00b6 Supported Frameworks \u00b6 Django Sanic Comming soon \u00b6 BlackSheep Click FastApi Flask Missing Support \u00b6","title":"Overview"},{"location":"frameworks/index.html#framework-integration","text":"","title":"Framework Integration"},{"location":"frameworks/index.html#supported-frameworks","text":"Django Sanic","title":"Supported Frameworks"},{"location":"frameworks/index.html#comming-soon","text":"BlackSheep Click FastApi Flask","title":"Comming soon"},{"location":"frameworks/index.html#missing-support","text":"","title":"Missing Support"},{"location":"frameworks/django.html","text":"Django \u00b6 Django framework integration is provided the django-xdi adapter. Install \u00b6 pip install django-xdi or pip install xdi [ django ] Usage \u00b6 Please refer to the adapter documentation for usage details","title":"Django"},{"location":"frameworks/django.html#django","text":"Django framework integration is provided the django-xdi adapter.","title":"Django"},{"location":"frameworks/django.html#install","text":"pip install django-xdi or pip install xdi [ django ]","title":"Install"},{"location":"frameworks/django.html#usage","text":"Please refer to the adapter documentation for usage details","title":"Usage"},{"location":"frameworks/sanic.html","text":"Sanic \u00b6 Sanic framework integration is provided the sanic-xdi adapter. Install \u00b6 pip install sanic-xdi or pip install xdi [ sanic ] Usage \u00b6 Please refer to the adapter documentation for usage details","title":"Sanic"},{"location":"frameworks/sanic.html#sanic","text":"Sanic framework integration is provided the sanic-xdi adapter.","title":"Sanic"},{"location":"frameworks/sanic.html#install","text":"pip install sanic-xdi or pip install xdi [ sanic ]","title":"Install"},{"location":"frameworks/sanic.html#usage","text":"Please refer to the adapter documentation for usage details","title":"Usage"}]}